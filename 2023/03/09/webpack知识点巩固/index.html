<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>webpack知识点巩固 - Wee&#039;s Blog</title><meta description="1. 什么是 Webpack？1.1 回答webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。它主要解决的问题是将多个模块（Module）打包成一个或多个文件，并且在这个过程中还支持一些特性，如代码分离、文件压缩等。 我们先将着重点落在 静态模块打包工具 上，为什么是 静态模块打包工具？ 是因为它可以将多个模块（JavaScript 文件、CSS 文件、图片 等）打"><meta property="og:type" content="blog"><meta property="og:title" content="webpack知识点巩固"><meta property="og:url" content="http://weechou1118.github.io/2023/03/09/webpack%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/"><meta property="og:site_name" content="Wee&#039;s Blog"><meta property="og:description" content="1. 什么是 Webpack？1.1 回答webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。它主要解决的问题是将多个模块（Module）打包成一个或多个文件，并且在这个过程中还支持一些特性，如代码分离、文件压缩等。 我们先将着重点落在 静态模块打包工具 上，为什么是 静态模块打包工具？ 是因为它可以将多个模块（JavaScript 文件、CSS 文件、图片 等）打"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://weechou1118.github.io/img/thumbnail/goodeat.jpg"><meta property="article:published_time" content="2023-03-09T02:43:17.000Z"><meta property="article:modified_time" content="2023-03-13T02:51:33.840Z"><meta property="article:author" content="Wee Chou"><meta property="article:tag" content="Webpack"><meta property="article:tag" content="性能优化"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/thumbnail/goodeat.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://weechou1118.github.io/2023/03/09/webpack%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/"},"headline":"Wee's Blog","image":["http://weechou1118.github.io/img/thumbnail/goodeat.jpg"],"datePublished":"2023-03-09T02:43:17.000Z","dateModified":"2023-03-13T02:51:33.840Z","author":{"@type":"Person","name":"Wee Chou"},"description":"1. 什么是 Webpack？1.1 回答webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。它主要解决的问题是将多个模块（Module）打包成一个或多个文件，并且在这个过程中还支持一些特性，如代码分离、文件压缩等。 我们先将着重点落在 静态模块打包工具 上，为什么是 静态模块打包工具？ 是因为它可以将多个模块（JavaScript 文件、CSS 文件、图片 等）打"}</script><link rel="canonical" href="http://weechou1118.github.io/2023/03/09/webpack%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.14.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.14.0/css/all.min.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Wee&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="/img/thumbnail/goodeat.jpg" alt="webpack知识点巩固"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2023-03-09T02:43:17.000Z" title="2023-03-09T02:43:17.000Z">2023-03-09</time><span class="level-item"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></span><span class="level-item">1 小时 读完 (大约 7775 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">webpack知识点巩固</h1><div class="content"><h1 id="1-什么是-Webpack？"><a href="#1-什么是-Webpack？" class="headerlink" title="1. 什么是 Webpack？"></a>1. 什么是 Webpack？</h1><h2 id="1-1-回答"><a href="#1-1-回答" class="headerlink" title="1.1 回答"></a>1.1 回答</h2><p><code>webpack</code> 是一个用于现代 <code>JavaScript</code> 应用程序的 <strong>静态模块打包工具</strong>。它主要解决的问题是将多个模块（Module）打包成一个或多个文件，并且在这个过程中还支持一些特性，如代码分离、文件压缩等。</p>
<p>我们先将着重点落在 <strong><code>静态模块打包工具</code></strong> 上，为什么是 <code>静态模块打包工具</code>？</p>
<p>是因为它可以将<strong>多个模块</strong>（<code>JavaScript 文件</code>、<code>CSS 文件</code>、<code>图片</code> 等）<strong>打包成一个或多个静态资源文件</strong>。静态资源文件包含了应用程序中的所有依赖关系和逻辑，可以直接在浏览器中加载和运行。</p>
<h2 id="1-2-webpack-打包示例"><a href="#1-2-webpack-打包示例" class="headerlink" title="1.2 webpack 打包示例"></a>1.2 webpack 打包示例</h2><p>下面我们就来演示一个最简单的 webpack 打包示例：</p>
<ol>
<li><p>首先我们创建一个目录，初始化 <code>npm</code>，然后 <strong>在本地安装</strong> <code>webpack</code>，接着安装 <code>webpack-cli</code>（注意：此工具用于在命令行中运行 <code>webpack</code>）：</p>
<p>mkdir webpack-demo<br>cd webpack-demo<br>npm init -y<br>npm install webpack webpack-cli –save-dev<br>复制代码</p>
</li>
<li><p>现在，我们将创建以下目录结构、文件和内容：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1650ef14ac64769935906d6627e9efc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p><code>add.js</code>：</p>
<pre><code>export function add(n1, n2) {
  return n1 + n2;
}
复制代码</code></pre><p><code>sub.js</code></p>
<pre><code>export function sub(n1, n2) {
  return n1 - n2;
}
复制代码</code></pre><p><code>index.js</code></p>
<pre><code>import { add } from &quot;./add&quot;;
import { sub } from &quot;./sub&quot;;

console.log(add(1, 2));
console.log(sub(1, 2));
复制代码</code></pre><p>可以看到，我们做的仅仅定义了两个工具文件 <code>a.js</code> 和 <code>b.js</code>，并在 <code>index.js</code> 中导入并且调用了两个函数。</p>
<ol start="3">
<li>接着，我们执行 <code>npx webpack</code> 命令进行打包，打包结果如下图所示：</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e73b5673bfec4bcaaaa24158ebd37c01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91b67b2f3711405ba3dbac532c6f282a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>可以这样说，执行 <code>npx webpack</code>，会将我们的脚本 <code>src/index.js</code> 作为 <strong>入口起点</strong>，也会生成 <code>dist/main.js</code> 作为 输出。<code>Node 8.2/npm 5.2.0</code> 以上版本提供的 <code>npx</code> 命令，可以运行在初次安装的 <code>webpack package</code> 中的 <code>webpack</code> 二进制文件（即 <code>./node_modules/.bin/webpack</code>）。</p>
<a id="more"></a>
<h2 id="1-3-模块"><a href="#1-3-模块" class="headerlink" title="1.3 模块"></a>1.3 模块</h2><p>在上面的例子中，我们仅仅演示了 <code>es6</code> 的模块化导入导出，事实上除了 <code>import</code> 和 <code>export</code>，<code>webpack</code> 还能够很好地支持多种其他模块语法比如 <code>CommonJS</code>、<code>AMD</code>等</p>
<h2 id="1-4-配置文件"><a href="#1-4-配置文件" class="headerlink" title="1.4 配置文件"></a>1.4 配置文件</h2><p>在 <code>webpack v4</code> 中，可以无须任何配置，然而大多数项目会需要很复杂的设置，这时候就需要一个配置文件来拯救我们了，因为这比在 <code>terminal(终端)</code> 中手动输入大量命令要高效的多</p>
<ol>
<li><p>创建 <code>webpack-demo/webpack.config.js</code></p>
<p>const path = require(‘path’);</p>
<p>module.exports = {<br>  entry: ‘./src/index.js’,<br>  output: {</p>
<pre><code>filename: &apos;bundle.js&apos;,
path: path.resolve(__dirname, &apos;dist&apos;),</code></pre><p>  },<br>};<br>复制代码</p>
</li>
<li><p>执行打包命令 <code>npx webpack --config webpack.config.js</code>。</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/634d86fd68544fcbaa07fccfb4637faf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>可以看到生成的新的文件名为 <code>bundle.js</code> 说明我们的配置文件已经生效。</p>
<p>事实上，如果 <code>webpack.config.js</code> 存在，则 <code>webpack</code> 命令将默认选择使用它，所以我们依然可以使用 <code>npx webpack</code> 进行打包。这里使用 <code>--config</code> 选项只是表明可以传递任何名称的配置文件，这对于需要拆分成多个文件的复杂配置是非常有用的。</p>
<h2 id="1-5-npm-scripts"><a href="#1-5-npm-scripts" class="headerlink" title="1.5 npm scripts"></a>1.5 npm scripts</h2><p>考虑到用 <code>CLI</code> 这种方式来运行本地的 <code>webpack</code> 副本并不是特别方便，我们可以设置一个快捷方式。调整 <code>package.json</code> 文件，添加一个 <code>npm script</code>：</p>
<pre><code> &quot;build&quot;: &quot;webpack&quot;
复制代码</code></pre><p>现在，可以使用 <code>npm run build</code> 命令，来替代我们之前使用的 <code>npx</code> 命令。注意，使用 <code>npm scripts</code>，我们可以像使用 <code>npx</code> 那样通过模块名引用本地安装的 <code>npm packages</code>。这是大多数基于 <code>npm</code> 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本。</p>
<h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h2><p>在这一题中，我们使用了一个最简单的案例来解释了 <code>webpack</code> 是什么东西，它的本质就是一个模块化的打包工具，我想大家应该对它的概念都能有一个基本的了解了。</p>
<h1 id="2-Webpack-的核心概念有哪些？"><a href="#2-Webpack-的核心概念有哪些？" class="headerlink" title="2. Webpack 的核心概念有哪些？"></a>2. Webpack 的核心概念有哪些？</h1><p><code>Webpack</code> 的核心概念主要包括以下几个：</p>
<ol>
<li>入口 Entry</li>
<li>输出 Output</li>
<li>加载器 Loader</li>
<li>插件 Plugin</li>
<li>模式 Mode</li>
<li>浏览器兼容性 Browser compatibility</li>
<li>环境 Environment</li>
<li>代码块 Chunk</li>
<li>模块 Module</li>
</ol>
<h2 id="2-1-入口-Entry"><a href="#2-1-入口-Entry" class="headerlink" title="2.1 入口 Entry"></a>2.1 入口 Entry</h2><p>入口起点(entry point) 定义 <code>webpack</code> <strong>从哪个文件开始构建依赖关系图</strong>，进入入口起点后，<code>webpack</code> 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
<p>它的默认值是 <code>./src/index.js</code>，但是我们可以通过在配置文件中配置 <code>entry</code>属性来指定一个（或多个）不同的入口起点。例如：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code>module.exports = {
  entry: &apos;./path/to/my/entry/file.js&apos;,
};
复制代码</code></pre><h2 id="2-2-输出-Output"><a href="#2-2-输出-Output" class="headerlink" title="2.2 输出 Output"></a>2.2 输出 Output</h2><p><code>output</code> 属性告诉 <code>webpack</code> 在哪里输出它所创建的 <code>bundle</code>，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p>
<p>你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p>
<pre><code>const path = require(&apos;path&apos;);

module.exports = {
  entry: &apos;./path/to/my/entry/file.js&apos;,
  output: {
    path: path.resolve(__dirname, &apos;dist&apos;),
    filename: &apos;my-first-webpack.bundle.js&apos;,
  },
};
复制代码</code></pre><p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 <code>webpack bundle</code> 的名称，以及我们想要 <code>bundle</code> 生成(<code>emit</code>)到哪里。</p>
<h2 id="2-3-加载器-Loader"><a href="#2-3-加载器-Loader" class="headerlink" title="2.3 加载器 Loader"></a>2.3 加载器 Loader</h2><p><code>webpack</code> 只能理解 <code>JavaScript</code> 和 <code>JSON</code> 文件。<code>loader</code> 的作用就是让让 <code>webpack</code> 能够去处理其他类型的文件，并将它们转换为 <code>JavaScript</code> 文件。</p>
<p>在 <code>webpack</code> 的配置中，<code>loader</code> 有两个属性：</p>
<ol>
<li><code>test</code> 属性，识别出哪些文件会被转换。</li>
<li><code>use</code> 属性，定义出在进行转换时，应该使用哪个 <code>loader</code>。</li>
</ol>
<p><strong>webpack.config.js</strong></p>
<pre><code>const path = require(&apos;path&apos;);

module.exports = {
  output: {
    filename: &apos;my-first-webpack.bundle.js&apos;,
  },
  module: {
    rules: [{ test: /\.txt$/, use: &apos;raw-loader&apos; }],
  },
};
复制代码</code></pre><p>以上配置中，对一个单独的 <code>module</code> 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 <code>webpack 编译器(compiler)</code> 如下信息：</p>
<blockquote>
<p><code>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 &#39;.txt&#39; 的路径」时，在你对它打包之前，先 use(使用) raw-loader 转换一下。”</code></p>
</blockquote>
<h2 id="2-4-插件-Plugin"><a href="#2-4-插件-Plugin" class="headerlink" title="2.4 插件 Plugin"></a>2.4 插件 Plugin</h2><p>webpack 中 <code>loader</code> 用于转换某些类型的模块，而插件则可以用于<strong>执行范围更广的任务</strong>。包括：<strong>打包优化</strong>，<strong>资源管理</strong>，<strong>注入环境变量</strong>。插件目的在于<strong>解决 <code>loader</code> 无法实现的其他事</strong>。</p>
<p>想要使用一个插件，只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(<code>option</code>)自定义。也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
const webpack = require(&apos;webpack&apos;); // 用于访问内置插件

module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: &apos;raw-loader&apos; }],
  },
  plugins: [new HtmlWebpackPlugin({ template: &apos;./src/index.html&apos; })],
};
复制代码</code></pre><p>在上面的示例中，<code>html-webpack-plugin</code> 为应用程序生成一个 <code>HTML</code> 文件，并自动将生成的所有 <code>bundle</code> 注入到此文件中。</p>
<h2 id="2-5-模式-Mode"><a href="#2-5-模式-Mode" class="headerlink" title="2.5 模式 Mode"></a>2.5 模式 Mode</h2><p><code>Webpack</code> 有三种模式：<code>development</code>、<code>production</code> 和 <code>none</code>。通过设置不同的模式，可以启用不同的内置优化。</p>
<h2 id="2-6-浏览器兼容性-Browser-compatibility"><a href="#2-6-浏览器兼容性-Browser-compatibility" class="headerlink" title="2.6 浏览器兼容性 Browser compatibility"></a>2.6 浏览器兼容性 Browser compatibility</h2><p><code>Webpack</code> 支持所有符合 <code>ES5</code> 标准 的浏览器（不支持 IE8 及以下版本）。</p>
<h2 id="2-7-环境-Environment"><a href="#2-7-环境-Environment" class="headerlink" title="2.7 环境 Environment"></a>2.7 环境 Environment</h2><p><code>Webpack 5</code> 运行于 <code>Node.js v10.13.0+</code> 的版本。</p>
<h2 id="2-8-代码块-Chunk"><a href="#2-8-代码块-Chunk" class="headerlink" title="2.8 代码块 Chunk"></a>2.8 代码块 Chunk</h2><p><code>chunk</code> 可以理解为 <code>webpack</code> 构建输出的一个文件，通常包含了在<strong>构建过程中</strong>生成的一些代码块。<code>webpack</code> 将所有相关的模块打包在一起，以此生成<strong>一个或多个chunk</strong> 。这些 <code>chunk</code> 可以是 <strong>JavaScript文件、CSS文件、图片</strong>等，也可以是异步加载的代码块。</p>
<p><code>webpack</code> 将代码分割成多个 <code>chunk</code> 的主要目的是优化应用程序的性能。通过将代码拆分成多个小块，<code>webpack</code> 可以减少初始加载时间，并提高应用程序的性能。</p>
<h2 id="2-9-模块-Module"><a href="#2-9-模块-Module" class="headerlink" title="2.9 模块 Module"></a>2.9 模块 Module</h2><p><code>Webpack</code> 会将所有的文件都看作一个个模块，每个模块都有自己的依赖关系，<code>Webpack</code> 会根据这些依赖关系构建出一个依赖关系图。</p>
<h1 id="3-请解释一下-Webpack-的打包原理"><a href="#3-请解释一下-Webpack-的打包原理" class="headerlink" title="3. 请解释一下 Webpack 的打包原理"></a>3. 请解释一下 Webpack 的打包原理</h1><p><code>Webpack</code> 的打包原理可以简单地概括为以下几个步骤：</p>
<ol>
<li><p><strong>解析入口文件</strong>：<code>Webpack</code> 通过指定的入口文件开始打包，从该文件开始分析和解析整个项目的依赖关系。</p>
</li>
<li><p><strong>依赖分析</strong>：<code>Webpack</code> 根据模块之间的依赖关系，递归地分析和收集所有需要打包的模块，包括 <strong><code>JavaScript</code>、<code>CSS</code>、图片</strong>等资源文件。</p>
</li>
<li><p><strong>模块转换</strong>：<code>Webpack</code> 在解析模块的过程中，会根据不同的模块类型，将它们转换成 <code>JavaScript</code> 代码，以便在浏览器中执行。</p>
</li>
<li><p><strong>生成 <code>Chunk</code></strong>：<code>Webpack</code> 会将所有模块打包成<strong>一个或多个 <code>Chunk</code></strong>，每个 <code>Chunk</code> 包含了一组模块，以及这些模块之间的依赖关系。</p>
</li>
<li><p><strong>生成 <code>Bundle</code></strong>：最后，<code>Webpack</code> 会将所有的 <code>Chunk</code> 生成对应的静态资源文件，例如 <strong>JavaScript、CSS、图片</strong>等，供浏览器加载和执行。</p>
</li>
</ol>
<p>在整个打包过程中，<code>Webpack</code> 提供了很多插件和配置选项，可以帮助我们自定义打包过程，例如<strong>代码压缩、分离 <code>CSS</code> 文件、处理图片</strong> 等。同时，<code>Webpack</code> 还支持使用各种 <code>Loader</code> 来处理不同类型的模块，例如使用 <code>Babel Loader</code> 来处理 <code>ES6</code> 语法的模块。</p>
<h2 id="3-1-chunk-和-bundle-的区别是什么？"><a href="#3-1-chunk-和-bundle-的区别是什么？" class="headerlink" title="3.1 chunk 和 bundle 的区别是什么？"></a>3.1 chunk 和 bundle 的区别是什么？</h2><p><strong>chunk</strong>：<code>chunk</code> 是 <code>Webpack</code> 打包生成的一个或多个 <code>JavaScript</code> 文件，它包含了一组相关的模块的代码，可以看做是模块的集合。在实际开发中，<code>chunk</code> 可以用于实现代码分割、按需加载、懒加载等功能，从而优化代码的加载和执行，提高应用的性能和用户体验。</p>
<p><strong>bundle</strong>：<code>bundle</code> 是 <code>Webpack</code> 打包生成的一个或多个静态资源文件，它包含了所有模块的代码，可以看做是代码的最终打包结果。在实际开发中，<code>bundle</code> 可以用于发布到生产环境，供浏览器加载和执行。</p>
<p>简单来说，<strong><code>chunk</code> 是 <code>Webpack</code> 在打包过程中产生的中间文件，<code>bundle</code> 是最终生成的静态资源文件</strong>。在代码分割和按需加载的场景下，<code>Webpack</code> 会生成多个 <code>chunk</code> 文件，每个文件包含一部分模块的代码，然后将这些 <code>chunk</code> 文件合并成一个或多个 <code>bundle</code> 文件，以便在浏览器中加载和执行。</p>
<h1 id="4-如何使用-Webpack-进行代码分割"><a href="#4-如何使用-Webpack-进行代码分割" class="headerlink" title="4. 如何使用 Webpack 进行代码分割"></a>4. 如何使用 Webpack 进行代码分割</h1><p><strong>代码分离（Code Spliting）</strong> 是 <code>webpack</code> 一个非常重要的特性，它主要的目的是<strong>将代码剥离到不同的 <code>bundle</code></strong> 中，之后我们可以<strong>按需加载</strong>，或者<strong>并行加载这些文件</strong>。</p>
<p><code>webpack</code> 常用的代码分离方式有<strong>三种</strong>：</p>
<ol>
<li>入口起点：使用 <code>entry</code> 配置手动分离代码；</li>
<li>防止重复：使用 <code>EntryDependencies</code> 或者 <code>SplitChunksPlugin</code> 去重和分离代码：</li>
<li>动态导入：通过模块的内联函数用来分离代码</li>
</ol>
<h2 id="4-1-方式一：多入口起点"><a href="#4-1-方式一：多入口起点" class="headerlink" title="4.1 方式一：多入口起点"></a>4.1 方式一：多入口起点</h2><p>这是迄今为止最简单直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患，我们将会解决这些问题。</p>
<p>先来看看如何从 <code>main bundle</code> 中分离 <code>another module</code>(另一个模块)</p>
<h3 id="4-1-1-没有代码分离时"><a href="#4-1-1-没有代码分离时" class="headerlink" title="4.1.1 没有代码分离时"></a>4.1.1 没有代码分离时</h3><p>创建一个小的 <code>demo</code>：</p>
<ol>
<li><p>首先我们创建一个目录，初始化 <code>npm</code>，然后在本地安装 <code>webpack</code>、<code>webpack-cli</code>、<code>loadsh</code></p>
<p>mkdir webpack-demo<br>cd webpack-demo<br>npm init -y<br>npm install webpack webpack-cli lodash –save-dev<br>复制代码</p>
</li>
<li><p>创建 <code>src/index.js</code>：</p>
<p>import _ from “lodash”;</p>
<p>console.log(_);<br>复制代码</p>
</li>
<li><p>创建 <code>src/another-module.js</code>：</p>
<p>import _ from ‘lodash’;</p>
<p>console.log(_);<br>复制代码</p>
</li>
<li><p>创建 <code>webpack.config.js</code>：</p>
<p>const path = require(“path”);</p>
<p>module.exports = {<br>  mode: “development”,<br>  entry: “./src/index.js”,<br>  output: {</p>
<pre><code>path: path.resolve(__dirname, &quot;dist&quot;),
filename: &quot;main.js&quot;,</code></pre><p>  },<br>};<br>复制代码</p>
</li>
<li><p>在 <code>package.json</code> 中添加命令：</p>
<p>“scripts”: {<br>  “build”: “webpack”<br>},<br>复制代码</p>
</li>
<li><p>执行命令进行打包：</p>
<p>npm run build<br>复制代码</p>
</li>
<li><p>生成如下构建结果：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/149f290bd92e44418565a5bb1331db7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>可以看到此时生成了一个 <code>554KB</code> 的 <code>main.js</code> 文件</p>
<h3 id="4-1-2-有代码分离时"><a href="#4-1-2-有代码分离时" class="headerlink" title="4.1.2 有代码分离时"></a>4.1.2 有代码分离时</h3><p>接下来我们从 <code>main bundle</code> 中分离出 <code>another module</code>(另一个模块)</p>
<ol>
<li><p>修改 <code>webpack.config.js</code></p>
<p>const path = require(“path”);<br>module.exports = {<br>  mode: “development”,</p>
<ul>
<li>entry: ‘./src/index’,</li>
</ul>
<ul>
<li>entry: {</li>
<li>index: ‘./src/index’,</li>
<li>another: ‘./src/another-module.js’</li>
<li>},<br>output: {<br> path: path.resolve(__dirname, “dist”),</li>
</ul>
<ul>
<li>filename: “main.js”,</li>
</ul>
<ul>
<li>filename: “[name].main.js”,<br>},<br>};<br>复制代码</li>
</ul>
</li>
<li><p>打包，生成如下构建结果：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c43eb179a254428b4f82c4518a9291a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>我们发现此时已经成功打包出 <code>another.bundle.js</code> 和 <code>index.bundle.js</code> 两个文件了，但是文件的大小似乎有些问题，怎么两个都是 <code>554KB</code>？</p>
<p>正如前面提到的，这种方式存在一些隐患：</p>
<ol>
<li>如果入口 <code>chunk</code> 之间包含一些重复的模块，那些重复模块都会被引入到各个 <code>bundle</code> 中。</li>
<li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。</li>
</ol>
<p>以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 <code>./src/index.js</code> 中也引入过 <code>lodash</code>，这样就在两个 <code>bundle</code> 中造成重复引用。在下一小节我们将移除重复的模块。</p>
<h3 id="4-1-3-优化：移除重复的模块"><a href="#4-1-3-优化：移除重复的模块" class="headerlink" title="4.1.3 优化：移除重复的模块"></a>4.1.3 优化：移除重复的模块</h3><p>在通过多入口分离代码的方式中，我们可以通过配置 <code>dependOn</code> 这个选项来解决重复模块的问题，它的原理就是从两个文件中抽出一个共享的模块，然后再让这两个模块依赖这个共享模块。</p>
<ol>
<li><p>修改 <code>webpack.config.js</code> 配置文件：</p>
<p> const path = require(‘path’);</p>
<p> module.exports = {<br>   mode: ‘development’,<br>   entry: {</p>
<ul>
<li>index: ‘./src/index.js’,</li>
<li>another: ‘./src/another-module.js’,</li>
</ul>
<ul>
<li>index: {</li>
<li>import: ‘./src/index.js’,</li>
<li>dependOn: ‘shared’,</li>
<li>},</li>
<li>another: {</li>
<li>import: ‘./src/another-module.js’,</li>
<li>dependOn: ‘shared’,</li>
<li>},</li>
<li>shared: [‘lodash’],<br>},<br>output: {<br> filename: ‘[name].bundle.js’,<br> path: path.resolve(__dirname, ‘dist’),<br>},<br>};<br>复制代码</li>
</ul>
</li>
<li><p>打包，生成如下构建结果：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2d68768c4d44c93a0c59597bac2f273~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>可以看到 <code>index.mian.js</code> 和 <code>another.mian.js</code> 中重复引用的部分被抽离成了 <code>shared.main.js</code> 文件，且 <code>index.mian.js</code> 和 <code>another.mian.js</code> 文件大小也变小了。</p>
<h2 id="4-2-方式二：splitChunks-模式"><a href="#4-2-方式二：splitChunks-模式" class="headerlink" title="4.2 方式二：splitChunks 模式"></a>4.2 方式二：splitChunks 模式</h2><p>另外一种分包的模式是 <strong><code>splitChunks</code></strong>，它底层是使用 <strong><code>SplitChunksPlugin</code></strong> 来实现的：</p>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.webpackjs.com%2Fplugins%2Fsplit-chunks-plugin" title="https://www.webpackjs.com/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 插件可以将公共的依赖模块提取到已有的入口 <code>chunk</code> 中，或者提取到一个新生成的 <code>chunk</code>。</p>
</blockquote>
<p>因为该插件 <strong><code>webpack</code></strong> 已经默认安装和集成，所以我们并 <strong>不需要单独安装和直接使用该插</strong>件；只需要提供 <strong><code>SplitChunksPlugin</code></strong> 相关的配置信息即可</p>
<p><code>webpack</code> 提供了 <code>SplitChunksPlugin</code> 默认的配置，我们也可以手动来修改它的配置：</p>
<ul>
<li>比如默认配置中，<code>chunks</code> 仅仅针对于异步（<code>async</code>）请求，我们可以设置为 <code>initial</code> 或者 <code>all</code> ，</li>
</ul>
<h3 id="4-2-1-splitChunk-的配置"><a href="#4-2-1-splitChunk-的配置" class="headerlink" title="4.2.1 splitChunk 的配置"></a>4.2.1 splitChunk 的配置</h3><ol>
<li><p>在 <code>1.1.2</code> 的基础上修改 <code>webpack.cofig.js</code>：</p>
<p>  const path = require(‘path’);</p>
<p>  module.exports = {</p>
<pre><code>mode: &apos;development&apos;,
entry: {
  index: &apos;./src/index.js&apos;,
  another: &apos;./src/another-module.js&apos;,
},
output: {
  filename: &apos;[name].bundle.js&apos;,
  path: path.resolve(__dirname, &apos;dist&apos;),
},</code></pre><ul>
<li>optimization: {</li>
<li>splitChunks: {</li>
<li>chunks: ‘all’,</li>
<li>},</li>
<li>},<br>};<br>复制代码</li>
</ul>
</li>
<li><p>打包，生成如下构建结果：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a405ad900ae34d58a8509a90119264ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>使用 <code>optimization.splitChunks</code> 配置选项之后，现在应该可以看出，<code>index.bundle.js</code> 和 <code>another.bundle.js</code> 中已经移除了重复的依赖模块。需要注意的是，插件将 <code>lodash</code> 分离到单独的 <code>chunk</code>，并且将其从 <code>main</code> <code>bundle</code> 中移除，减轻了大小。</p>
<p>除了 <code>webpack</code> 默认继承的 <code>SplitChunksPlugin</code> 插件，社区中也有提供一些对于代码分离很有帮助的 <code>plugin</code> 和 <code>loader</code>，比如：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fmini-css-extract-plugin%2F" title="https://webpack.docschina.org/plugins/mini-css-extract-plugin/"><code>mini-css-extract-plugin</code></a>: 用于将 CSS 从主应用程序中分离。</li>
</ul>
<h3 id="4-2-2-SplitChunks-自定义配置解析"><a href="#4-2-2-SplitChunks-自定义配置解析" class="headerlink" title="4.2.2 SplitChunks 自定义配置解析"></a>4.2.2 SplitChunks 自定义配置解析</h3><p>关于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fsplit-chunks-plugin%2F" title="https://webpack.docschina.org/plugins/split-chunks-plugin/"><code>optimization.splitChunks</code></a> 文档上有很详细的记载，我这里讲你叫几个常用的：</p>
<p><strong>1. Chunks:</strong></p>
<ul>
<li>默认值是 <code>async</code></li>
<li>另一个值是 <code>initial</code>，表示对通过的代码进行处理</li>
<li><code>all</code> 表示对同步和异步代码都进行处理</li>
</ul>
<p><strong>2. <code>minSize</code> ：</strong></p>
<ul>
<li>拆分包的大小, 至少为 `minSize；</li>
<li>如果一个包拆分出来达不到 <code>minSize</code> ,那么这个包就不会拆分；</li>
</ul>
<p><strong>3. <code>maxSize</code>：</strong></p>
<ul>
<li>将大于maxSize的包，拆分为不小于minSize的包；</li>
</ul>
<p><strong>4. cacheGroups：</strong></p>
<ul>
<li>用于对拆分的包就行分组，比如一个 <code>lodash</code> 在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打包；</li>
<li><code>test</code> 属性：匹配符合规则的包；</li>
<li><code>name</code> 属性：拆分包的 <code>name</code> 属性；</li>
<li><code>filename</code> 属性：拆分包的名称，可以自己使用 <code>placeholder</code> 属性；</li>
</ul>
<ol>
<li><p>修改 <code>webpack.config.js</code></p>
<p>const path = require(“path”);</p>
<p>module.exports = {<br>  mode: “development”,<br>  entry: {</p>
<pre><code>index: &quot;./src/index.js&quot;,
another: &quot;./src/another-module.js&quot;,</code></pre><p>  },<br>  output: {</p>
<pre><code>filename: &quot;[name].bundle.js&quot;,
path: path.resolve(__dirname, &quot;dist&quot;),</code></pre><p>  },<br>  optimization: {</p>
<pre><code>splitChunks: {
  chunks: &quot;all&quot;,
  // 拆分包的最小体积
  // 如果一个包拆分出来达不到 minSize，那么这个包就不会拆分（会被合并到其他包中）
  minSize: 100,
  // 将大于 maxSize 的包，拆分成不小于 minSize 的包
  maxSize: 10000,

  // 自己对需要拆包的内容进行分组
  cacheGroups: {
    自定义模块的name: {
      test: /node_modules/,
      filename: &quot;[name]_vendors.js&quot;,
    },
  },
},</code></pre><p>  },<br>};<br>复制代码</p>
</li>
<li><p>打包，生成如下构建结果：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a146674d89db453784f916571c150261~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<h2 id="4-3-方式三：动态导入-dynamic-import"><a href="#4-3-方式三：动态导入-dynamic-import" class="headerlink" title="4.3 方式三：动态导入(dynamic import)"></a>4.3 方式三：动态导入(dynamic import)</h2><p>另外一个代码拆分的方式是动态导入时，<code>webpack</code> 提供了两种实现动态导入的方式：</p>
<ul>
<li>第一种，使用 <code>ECMAScript</code> 中的 <code>import()</code> 语法来完成，也是目前推荐的方式；</li>
<li>第二种，使用 <code>webpack</code> 遗留的 <code>require.ensure</code>，目前已经不推荐使用；</li>
</ul>
<p><strong>动态 <code>import</code> 使用最多的一个场景是懒加载（比如路由懒加载）</strong></p>
<h3 id="4-3-1-import-方式"><a href="#4-3-1-import-方式" class="headerlink" title="4.3.1 import 方式"></a>4.3.1 import 方式</h3><p>接着从 <code>1.1.2</code> 小节代码的基础上修改：</p>
<ol>
<li><p>修改 <code>webpack.confg.js</code>：</p>
<p>const path = require(“path”);</p>
<p>module.exports = {<br>  entry: “./src/index.js”,<br>  mode: “development”,<br>  entry: {</p>
<pre><code>index: &quot;./src/index.js&quot;,</code></pre><p>  },<br>  output: {</p>
<pre><code>filename: &quot;[name].bundle.js&quot;,
path: path.resolve(__dirname, &quot;dist&quot;),</code></pre><p>  },<br>};<br>复制代码</p>
</li>
<li><p>删除 <code>src/another-module.js</code> 文件</p>
</li>
<li><p>修改 <code>src/index.js</code>，不再使用 <code>statically import</code> (静态导入) <code>lodash</code>，而是通过 <code>dynamic import</code>(动态导入) 来分离出一个 <code>chunk</code>：</p>
</li>
</ol>
<pre><code>const logLodash = function () {
  import(&quot;lodash&quot;).then(({ default: _ }) =&gt; {
    console.log(_);
  });
};

logLodash();
复制代码</code></pre><p>之所以需要 <code>default</code>，是因为 <code>webpack 4</code> 在导入 <code>CommonJS</code> 模块时，将不再解析为 <code>module.exports</code> 的值，而是为 <code>CommonJS</code> 模块创建一个 <code>artificial namespace</code> 对象。</p>
<ol start="4">
<li>打包，生成如下构建结果：</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce8dfe6877994f68af8100bcb583a726~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>由于 <code>import()</code> 会返回一个 <code>promise</code>，因此它可以和 <code>async</code> 函数一起使用。下面是如何通过 <code>async</code> 函数简化代码：</p>
<pre><code>const logLodash = async function () {
  const { default: _ } = await import(&quot;lodash&quot;);

  console.log(_);
};

logLodash();
复制代码</code></pre><h3 id="4-3-2-动态导入的文件命名"><a href="#4-3-2-动态导入的文件命名" class="headerlink" title="4.3.2 动态导入的文件命名"></a>4.3.2 动态导入的文件命名</h3><p>因为动态导入通常是一定会打包成独立的文件的，所以并不会再 <code>cacheGroups</code> 中进行配置；</p>
<p>它的命名我们通常会在 <code>output</code> 中，通过 <code>chunkFilename</code> 属性来命名：</p>
<ol>
<li><p>修改 <code>webpack.config.js</code></p>
<p>const path = require(“path”);</p>
<p>module.exports = {<br>  entry: “./src/index.js”,<br>  mode: “development”,<br>  entry: {</p>
<pre><code>index: &quot;./src/index.js&quot;,</code></pre><p>  },<br>  output: {</p>
<pre><code>filename: &quot;[name].bundle.js&quot;,
path: path.resolve(__dirname, &quot;dist&quot;),</code></pre><ul>
<li>chunkFilename: “chunk_[name].js””<br>},<br>};</li>
</ul>
<p>复制代码</p>
</li>
<li><p>打包构建：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a6b6fcfa387488889dbdd1c2e9c1d7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>如果对打包后的 <code>[name]</code> 不满意，还可以通过 <code>magic comments</code>（魔法注释）来修改：</p>
<p>1， 修改 <code>src/index.js</code>：</p>
<pre><code>const logLodash = async function () {
  const { default: _ } = await import(/*webpackChunkName: &apos;lodash&apos;*/ &quot;lodash&quot;);

  console.log(_);
};

logLodash();
复制代码</code></pre><ol start="2">
<li>打包构建</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93fc40c78d314b84b65da73426e587d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<h1 id="5-什么是-Tree-Shaking？如何使用-Webpack-实现？"><a href="#5-什么是-Tree-Shaking？如何使用-Webpack-实现？" class="headerlink" title="5. 什么是 Tree Shaking？如何使用 Webpack 实现？"></a>5. 什么是 Tree Shaking？如何使用 Webpack 实现？</h1><p><strong>什么是 <code>Tree Shaking</code> ？</strong></p>
<ul>
<li><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码（<code>dead_code</code>）；</li>
<li>最早的想法起源于 <code>LISP</code>，用于消除未调用的代码（纯函数无副作用，可以放心的消除，这也是为什么要求我们在进行函数式编程时，尽量使用纯函数的原因之一）；</li>
<li>后来 <code>Tree Shaking</code> 也被应用于其他的语言，比如 <code>JavaScript</code>、<code>Dart</code>；</li>
</ul>
<p><strong><code>JavaScript</code> 的 <code>Tree Shaking</code>：</strong></p>
<ul>
<li>对 <code>JavaScript</code> 进行 <code>Tree Shaking</code> 是源自打包工具 <code>rollup</code>；</li>
<li>这是因为 <code>Tree Shaking</code> 依赖于 <code>ES Module</code> 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）；</li>
<li><code>webpack2</code> 正式内置支持了 <code>ES2015</code> 模块，和检测未使用模块的能力；</li>
<li>在 <code>webpack4</code> 正式扩展了这个能力，并且通过 <code>package.json</code> 的 <code>sideEffects</code> 属性作为标记，告知 <code>webpack</code> 在编译时，哪里文件可以安全的删除掉；</li>
<li><code>webpack5</code> 中，也提供了对部分 <code>CommonJS</code> 的 <code>tree shaking</code> 的支持； ✓ <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fchangelog-v5%23commonjs-tree-shaking" title="https://github.com/webpack/changelog-v5#commonjs-tree-shaking">github.com/webpack/cha…</a></li>
</ul>
<h2 id="5-1-webpack-实现-Tree-Shaking"><a href="#5-1-webpack-实现-Tree-Shaking" class="headerlink" title="5.1 webpack 实现 Tree Shaking"></a>5.1 webpack 实现 Tree Shaking</h2><p><code>webpack</code> 实现 <code>Tree Shaking</code> 采用了两种不同的方案：</p>
<ol>
<li><strong><code>usedExports</code></strong>：通过标记某些函数是否被使用，之后通过 <code>Terser</code> 来进行优化的；</li>
<li><strong><code>sideEffects</code></strong>：跳过整个模块/文件，直接查看该文件是否有副作用；</li>
</ol>
<p><code>usedExports</code> 按 <code>sideEffects</code> 这两个东西的优化是不同的事情。</p>
<blockquote>
<p>引用官方文档的话： The sideEffects and usedExports（more konwn as tree shaking）optimizations are two different things</p>
</blockquote>
<p>下面我们分别来演示一下这两个属性的使用</p>
<h3 id="5-1-1-usedExports"><a href="#5-1-1-usedExports" class="headerlink" title="5.1.1 usedExports"></a>5.1.1 usedExports</h3><ol>
<li><p>新建一个 <code>webpack-demo</code>。</p>
<p>mkdir webpack-demo<br>cd webpack-demo<br>npm init -y<br>npm install webpack webpack-cli lodash –save-dev<br>复制代码</p>
</li>
<li><p>创建 <code>src/math.js</code> 文件：</p>
<p>export const add = (num1, num2) =&gt; num1 + num2;<br>export const sub = (num1, num2) =&gt; num1 - num2;<br>复制代码</p>
</li>
</ol>
<p>在这个问价中仅是导出了两个函数方法</p>
<ol start="3">
<li><p>创建 <code>src/index.js</code> 文件：、</p>
<p>import { add, sub } from “./math”;</p>
<p>console.log(add(1, 2));<br>复制代码</p>
</li>
</ol>
<p>在 <code>index.js</code> 中 导入了刚刚创建的两个函数，但是只使用了 <code>add</code></p>
<ol start="4">
<li><p>配置 <code>webpack.config.js</code>：</p>
<p>const path = require(“path”);</p>
<p>module.exports = {<br>  mode: “development”,<br>  devtool: false,<br>  entry: “./src/index.js”,<br>  output: {</p>
<pre><code>path: path.resolve(__dirname, &quot;dist&quot;),
filename: &quot;main.js&quot;,</code></pre><p>  },<br>  optimization: {</p>
<pre><code>usedExports: true,</code></pre><p>  },<br>};<br>复制代码</p>
</li>
</ol>
<p>为了可以看到 <code>usedExports</code> 带来的效果，我们需要设置为 <code>development</code> 模式。因为在 <code>production</code> 模式下，<code>webpack</code> 默认的一些优化会带来很大的影响。</p>
<ol start="5">
<li>设置 <code>usedExports</code> 为 <code>true</code> 和 <code>false</code> 对比打包后的代码：</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/029fe3c870e349f8a9afbcbeae8b5493~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f58d63fd67c540008103c5fa10d32052~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>仔细观察上面两张图可以发现当设置 <code>usedExports: true</code> 时，<code>sub</code> 函数没有导出了，另外会多出一段注释：<code>unused harmony export mul</code>；这段注释的意义是会告知 <code>Terser</code> 在优化时，可以删除掉这段代码。</p>
<p><strong>这个时候，我们将 <code>minimize</code> 设置 <code>true</code>：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cc2cced078a40cc9ef20c6a5bc2f2cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a08dc164ac424feea7b28358a88b8add~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<ul>
<li><code>usedExports</code> 设置为 <code>false</code> 时，<code>sub</code> 函数没有被移除掉；</li>
<li><code>usedExports</code> 设置为 <code>true</code> 时，<code>sub</code> 函数有被移除掉；</li>
</ul>
<p><strong>所以，<code>usedExports</code> 实现 <code>Tree Shaking</code> 是结合 <code>Terser</code> 来完成的。</strong></p>
<h3 id="5-1-2-sideEffects"><a href="#5-1-2-sideEffects" class="headerlink" title="5.1.2 sideEffects"></a>5.1.2 sideEffects</h3><p>在一个纯粹的 <code>ESM</code> 模块世界中，很容易识别出哪些文件有副作用。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 <code>webpack compiler</code> 哪些代码是“纯粹部分”。</p>
<p>通过 <code>package.json</code> 的 <code>&quot;sideEffects&quot;</code> 属性，来实现这种方式。</p>
<pre><code>{
  &quot;name&quot;: &quot;your-project&quot;,
  &quot;sideEffects&quot;: false
}
复制代码</code></pre><p>如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 <code>false</code>，来告知 <code>webpack</code> 它可以安全地删除未用到的 <code>export</code>。</p>
<blockquote>
<p><code>&quot;side effect(副作用)&quot;</code> 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 <code>export</code> 或多个 <code>export</code>。举例说明，例如 <code>polyfill</code>，它影响全局作用域，并且通常不提供 <code>export</code>。</p>
</blockquote>
<p>如果你的代码确实有一些副作用，可以改为提供一个数组：</p>
<pre><code>{
  &quot;name&quot;: &quot;your-project&quot;,
  &quot;sideEffects&quot;: [&quot;./src/some-side-effectful-file.js&quot;]
}
复制代码</code></pre><blockquote>
<p>注意，所有导入文件都会受到 <code>tree shaking</code> 的影响。这意味着，如果在项目中使用类似 <code>css-loader</code> 并 <code>import</code> 一个 <code>CSS</code> 文件，则需要将其添加到 <code>side effect</code> 列表中，以免在生产模式中无意中将它删除：</p>
</blockquote>
<pre><code>{
  &quot;name&quot;: &quot;your-project&quot;,
  &quot;sideEffects&quot;: [&quot;./src/some-side-effectful-file.js&quot;, &quot;*.css&quot;]
}
复制代码</code></pre><h2 id="5-2-CSS-实现-Tree-Shaking"><a href="#5-2-CSS-实现-Tree-Shaking" class="headerlink" title="5.2 CSS 实现 Tree Shaking"></a>5.2 CSS 实现 Tree Shaking</h2><p>上面将的都是关于 <code>JavaScript</code> 的 <code>Tree Shaking</code> ，对于 <code>CSS</code> 同样有对应的 <code>Tree Shaking</code> 操作。</p>
<ul>
<li><p>在早期的时候，我们会使用 <code>PurifyCss</code> 插件来完成 <code>CSS</code> 的 <code>tree shaking</code>，但是目前该库已经不再维护了（最新更新也是在 <code>4</code> 年前了）；</p>
</li>
<li><p>目前我们可以使用另外一个库来完成 <code>CSS</code> 的 <code>Tree Shaking</code>：<code>PurgeCSS</code>，也是一个帮助我们删除未使用的 <code>CSS</code> 的工具；</p>
</li>
</ul>
<ol>
<li><p>安装 <code>PurgeCss</code> 的 <code>webpack</code> 插件：</p>
<p>npm install purgecss-webpack-plugin -D<br>复制代码</p>
</li>
<li><p>在 <code>webpack.config.js</code> 中配置 <code>PurgeCss</code></p>
<p>new PurgeCSSPlugin({<br>  paths: glob.sync(<code>${path.resolve(__dirname, &#39;../src&#39;)}/**/*</code>, { nodir: true }),<br>  only: [‘bundle’, ‘vendor’]<br>})<br>复制代码</p>
</li>
</ol>
<ul>
<li><code>paths</code>：表示要检测哪些目录下的内容需要被分析，这里我们可以使用 <code>glob</code>；</li>
<li>默认情况下，<code>Purgecss</code> 会将我们的 <code>html</code> 标签的样式移除掉，如果我们希望保留，可以添加一个 <code>safelist</code> 的属性；</li>
</ul>
<p><code>purgecss</code> 也可以对 <code>less</code>、<code>sass</code>文件进行处理（它是对打包后的 <code>css</code> 进行 <code>tree shaking</code> 操作）；</p>
<h1 id="6-Webpack-如何实现-Hot-Module-Replacement（HMR）"><a href="#6-Webpack-如何实现-Hot-Module-Replacement（HMR）" class="headerlink" title="6. Webpack 如何实现 Hot Module Replacement（HMR）"></a>6. Webpack 如何实现 Hot Module Replacement（HMR）</h1><p><code>Webpack</code> 实现 热更新 <code>Hot Module Replacement（HMR）</code>的主要原理是通过在运行时替换被修改的模块，而不需要重新加载整个页面或应用。</p>
<p>具体来说，<code>Webpack HMR</code> 的实现流程如下：</p>
<ol>
<li><p>首先，在入口文件中添加对 <code>HMR</code> 的支持，例如使用 <code>module.hot.accept</code> 方法或 <code>webpack-dev-server</code> 等工具提供的 <code>HMR API</code>。</p>
</li>
<li><p>当某个模块发生变化时，<code>Webpack</code> 会构建新的模块代码，并将其传递给 <code>HMR runtime</code>。</p>
</li>
<li><p><code>HMR runtime</code> 会将新的模块代码与当前运行的模块进行比较，找出发生变化的部分，然后将其应用到当前运行的模块上。</p>
</li>
<li><p>如果当前模块依赖其他模块，<code>HMR runtime</code> 会检查这些依赖模块是否也发生了变化，如果有，会递归执行上述操作，直到所有相关的模块都被更新为止。</p>
</li>
<li><p>最后，<code>HMR runtime</code> 会通知应用程序，告诉它哪些模块已经被更新，并提供一些回调函数，让应用程序可以根据需要进行一些额外的操作。</p>
</li>
</ol>
<p>总之，<strong><code>Webpack HMR</code> 通过在运行时替换被修改的模块，使应用程序可以保持运行状态，同时也提高了开发效率和用户体验</strong>。要实现 <code>HMR</code>，我们需要在入口文件中添加对 <code>HMR</code> 的支持，并使用 <code>webpack-dev-server</code> 或其他工具来提供 <code>HMR runtime</code> 的支持。</p>
<h1 id="7-请列举几个常用的-Webpack-插件"><a href="#7-请列举几个常用的-Webpack-插件" class="headerlink" title="7. 请列举几个常用的 Webpack 插件"></a>7. 请列举几个常用的 Webpack 插件</h1><ol>
<li><p><code>HtmlWebpackPlugin</code>：该插件可以根据指定的模板生成 <code>HTML</code> 文件，并自动将生成的 <code>JS</code> 和 <code>CSS</code> 文件引入到 <code>HTML</code> 中。</p>
</li>
<li><p><code>CleanWebpackPlugin</code>：该插件可以在每次构建之前清空输出目录，避免旧文件对新构建结果的影响。</p>
</li>
<li><p><code>MiniCssExtractPlugin</code>：该插件可以将 <code>CSS</code> 文件提取出来并单独打包成一个或多个文件，以便在浏览器中异步加载。</p>
</li>
<li><p><code>Webpack.DefinePlugin</code>：该插件可以定义全局变量，可以用来区分开发环境和生产环境等场景。</p>
</li>
<li><p><code>TerserWebpackPlugin</code>：该插件可以压缩 <code>JavaScript</code> 代码，减小文件大小，加快加载速度。</p>
</li>
<li><p><code>CopyWebpackPlugin</code>：该插件可以将某些文件或文件夹复制到输出目录中，例如静态资源文件等。</p>
</li>
</ol>
<h1 id="8-webpack-的优化策略有哪些"><a href="#8-webpack-的优化策略有哪些" class="headerlink" title="8. webpack 的优化策略有哪些?"></a>8. webpack 的优化策略有哪些?</h1><p><code>webpack</code> 的优化策略包括：</p>
<ol>
<li><strong><code>Tree Shaking</code></strong>：通过静态代码分析，找出未被引用的代码并在打包时剔除掉，以减少打包后的代码体积。</li>
<li><code>**Scope Hoisting</code>**：将模块中的所有函数作用域合并到一个函数作用域中，以减少代码体积和函数声明语句执行时间。</li>
<li><strong><code>Code Splitting</code></strong>：将代码按照路由或者功能进行拆分，实现按需加载，减少首屏加载时间。</li>
<li><strong>懒加载</strong>：将某些资源的加载延迟到真正需要时再进行加载，以减少首屏加载时间。</li>
<li><strong>长缓存</strong>：利用浏览器缓存机制，将打包后的文件按照版本号进行区分，提高页面访问速度。</li>
</ol>
<p>原文：<a href="https://yejiwei.com/post/126">https://yejiwei.com/post/126</a></p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Webpack/">Webpack</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/02/15/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"><span class="level-item">节流防抖</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: false,
            appId: 'dTG5WYzieK6AN6aIHe2mXBrx-gzGzoHsz',
            appKey: '8WRrGNPVOipY7JHu61hDgdny',
            placeholder: '(*ﾟДﾟ*) ',
            avatar: 'mp',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.jpg" alt="Wee Chou"></figure><p class="title is-size-4 is-block line-height-inherit">Wee Chou</p><p class="is-size-6 is-block">KEEP GOING</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/weech0u" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="http://rainlu.gitee.io/blog/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lu</span></span><span class="level-right"><span class="level-item tag">rainlu.gitee.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://xugaoyi.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Evan</span></span><span class="level-right"><span class="level-item tag">xugaoyi.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://acgtofe.com/posts/2021/03/web-emoji-input" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">acgtofe</span></span><span class="level-right"><span class="level-item tag">acgtofe.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/2023/03/09/webpack%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/"><p class="image is-64x64"><img class="thumbnail" src="/img/thumbnail/goodeat.jpg" alt="webpack知识点巩固"></p></a><div class="media-content size-small"><p><time dateTime="2023-03-09T02:43:17.000Z">2023-03-09</time></p><p class="title is-6"><a class="link-muted" href="/2023/03/09/webpack%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/">webpack知识点巩固</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><a class="media-left" href="/2023/02/15/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"><p class="image is-64x64"><img class="thumbnail" src="/img/thumbnail/sunset.jpg" alt="节流防抖"></p></a><div class="media-content size-small"><p><time dateTime="2023-02-15T02:39:13.000Z">2023-02-15</time></p><p class="title is-6"><a class="link-muted" href="/2023/02/15/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/">节流防抖</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></p></div></article><article class="media"><a class="media-left" href="/2023/02/13/%E5%9F%BA%E4%BA%8E-vite4-vue3-TS-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%BA%93/"><p class="image is-64x64"><img class="thumbnail" src="/img/gaoloufeiji.jpg" alt="基于 vite4 + vue3 + TS 从零搭建一个组件库"></p></a><div class="media-content size-small"><p><time dateTime="2023-02-13T07:18:17.000Z">2023-02-13</time></p><p class="title is-6"><a class="link-muted" href="/2023/02/13/%E5%9F%BA%E4%BA%8E-vite4-vue3-TS-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%BA%93/">基于 vite4 + vue3 + TS 从零搭建一个组件库</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Vue/">Vue</a> / <a class="link-muted" href="/categories/Vue/Vue3/">Vue3</a></p></div></article><article class="media"><a class="media-left" href="/2022/10/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM/"><p class="image is-64x64"><img class="thumbnail" src="/img/thumbnail/contractdraw.jpg" alt="理解虚拟DOM"></p></a><div class="media-content size-small"><p><time dateTime="2022-10-27T07:15:36.000Z">2022-10-27</time></p><p class="title is-6"><a class="link-muted" href="/2022/10/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM/">理解虚拟DOM</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/React/">React</a> / <a class="link-muted" href="/categories/React/%E8%99%9A%E6%8B%9Fdom/">虚拟dom</a></p></div></article><article class="media"><a class="media-left" href="/2020/12/29/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><p class="image is-64x64"><img class="thumbnail" src="/img/thumbnail/subway.jpg" alt="常见排序算法"></p></a><div class="media-content size-small"><p><time dateTime="2020-12-29T05:41:41.000Z">2020-12-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/12/29/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">常见排序算法</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Flask/"><span class="level-start"><span class="level-item">Flask</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Flask/models/"><span class="level-start"><span class="level-item">models</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Javascript/ES6/"><span class="level-start"><span class="level-item">ES6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/async/"><span class="level-start"><span class="level-item">async</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/event/"><span class="level-start"><span class="level-item">event</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/new%E5%85%B3%E9%94%AE%E5%AD%97/"><span class="level-start"><span class="level-item">new关键字</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"><span class="level-start"><span class="level-item">作用域</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/%E5%8E%9F%E5%9E%8B/"><span class="level-start"><span class="level-item">原型</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"><span class="level-start"><span class="level-item">节流防抖</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Javascript/%E9%97%AD%E5%8C%85/"><span class="level-start"><span class="level-item">闭包</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Mac-OS/"><span class="level-start"><span class="level-item">Mac OS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Mac-OS/%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90/"><span class="level-start"><span class="level-item">应用推荐</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Nuxt/"><span class="level-start"><span class="level-item">Nuxt</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Nuxt/start/"><span class="level-start"><span class="level-item">start</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/React/"><span class="level-start"><span class="level-item">React</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/React/Create-React-App/"><span class="level-start"><span class="level-item">Create React App</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/Hook/"><span class="level-start"><span class="level-item">Hook</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/ToDoList/"><span class="level-start"><span class="level-item">ToDoList</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/redux-saga/"><span class="level-start"><span class="level-item">redux-saga</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/%E8%99%9A%E6%8B%9Fdom/"><span class="level-start"><span class="level-item">虚拟dom</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/React/%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E6%B1%A1%E6%9F%93/"><span class="level-start"><span class="level-item">解决样式污染</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Vue/Vue-cli2-x/"><span class="level-start"><span class="level-item">Vue-cli2.x</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Vue/Vue3/"><span class="level-start"><span class="level-item">Vue3</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/front-end-issues/"><span class="level-start"><span class="level-item">front end issues</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="level-start"><span class="level-item">性能优化</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSS-module/"><span class="tag">CSS module</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Diff/"><span class="tag">Diff</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ECMAScript-6/"><span class="tag">ECMAScript 6</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES7/"><span class="tag">ES7</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Flask/"><span class="tag">Flask</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hook/"><span class="tag">Hook</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node/"><span class="tag">Node</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nuxt/"><span class="tag">Nuxt</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Promise/"><span class="tag">Promise</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redux/"><span class="tag">Redux</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue-cli2-x/"><span class="tag">Vue-cli2.x</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/async/"><span class="tag">async</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debounce/"><span class="tag">debounce</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/issues/"><span class="tag">issues</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less/"><span class="tag">less</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less-loader/"><span class="tag">less-loader</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/new/"><span class="tag">new</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redux-saga/"><span class="tag">redux-saga</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typescript/"><span class="tag">typescript</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdom/"><span class="tag">vdom</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vite/"><span class="tag">vite</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue3/"><span class="tag">vue3</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%AD%A5/"><span class="tag">异步</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Wee&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2023 Wee Chou</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://weechou1118.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>