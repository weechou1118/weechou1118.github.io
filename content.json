{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"React ToDoList","text":"编写一个ToDoList以巩固知识 index.js （入口文件，渲染页面） 1234567import React from 'react'// 提供DOM特定的方法，及页面渲染import ReactDOM from 'react-dom' // ToDoList 组件import ToDoList from './ToDoList'ReactDOM.render(&lt;ToDoList /&gt;, document.getElementById('root')) ToDoList.js（父组件） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 相当于// import React from 'react'// import {Component} from 'react'import React, {Component} from 'react'// webpack提供的导入语法import './styles.css'import Item from './item';class ToDoList extends Component { constructor (props) { // React中，使用props和state来跟踪变量 super(props) this.state = { inputValue: '', list: ['item1', 'item2'] } } render () { return ( &lt;div&gt; &lt;label htmlFor=\"inputItem\"&gt;inputItem: &lt;/label&gt; &lt;input value={this.state.inputValue} onChange={this.itemChange.bind(this)}/&gt; &lt;button onClick={this.addItem.bind(this)}&gt;click me&lt;/button&gt; &lt;ul&gt; { // 使用map遍历html元素 this.state.list.map((item, index) =&gt; { return ( // 向子组件传递content index delete自定义变量 &lt;Item key={item+index} content={item} index={index} deleteItem={this.deleteItem.bind(this)} /&gt; ) }) } &lt;/ul&gt; &lt;/div&gt; ) } itemChange (event) { // React 需要用setState来改变state，而不能直接改变state this.setState({ inputValue: event.target.value }) } addItem () { this.setState({ // ES6 剩余项语法... 类似解构 list: [...this.state.list, this.state.inputValue] }) } deleteItem (index) { var list = this.state.list list.splice(index, 1) this.setState({ // 相当于list: list list }) }}export default ToDoList Item.js (子组件) 12345678910111213141516171819202122// eslint-disable-next-lineimport React, { Component } from 'react';class Item extends Component { // props用于父子组件出传值 constructor (props) { super(props) // 使render中onClick事件对应方法调用时，this指向当前实例 this.handleClick = this.handleClick.bind(this) } render () { return ( &lt;li onClick={this.handleClick}&gt;{this.props.content}&lt;/li&gt; ) } handleClick () { this.props.deleteItem(this.props.index) console.log(this.props) }}export default Item 第一行的eslint-disable-next-line注释，可以使注释行的下一行不会ESLint检测","link":"/2020/08/26/React_ToDoList/"},{"title":"Redux中间件","text":"","link":"/2020/09/11/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"title":"防抖函数","text":"在使用React，实现通过onChange事件修改input.value与state.value值的过程中，发现每次修改值（每按下键盘一次），都会调用onChange对应的方法，而我们往往只需要拿到敲击完键盘最后得到的结果就行了，频繁且多余的请求会消耗不必要的性能。我们可以利用防抖函数解决这一问题。 123456789101112//防抖函数function debounce(fn, ms=500) { let timer = null return function(e) { // 想要访问异步事件属性 e.persist() if(timer!==null) clearTimeout(timer) timer = setTimeout(() =&gt; { fn.apply(this, arguments) }, ms); }} 这样一来，每次监听到事件，会先在全局创建一个定时器，并在事件结束的若干毫秒后，再执行对应方法。 注意事项 每次创建定时器之前，若已经存在timer，为了避免定时器叠加，要清除已存在的定时器 e.persist()的解释: If you want to access the event properties in an asynchronous way, you should call event.persist() on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.中文解释（并非翻译）：如果在react中想异步访问事件属性（如在setTimeout内），应该在是处理事件时调用event.persist()，这会从事件池中移除该合成函数并允许对该合成事件的引用被保留下来。 由于传入的fn会在外部调用，且需要外部的作用域，因此用到apply绑定this：fn.apply(this, arguments)","link":"/2020/09/03/React%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0/"},{"title":"Flask入门（一）---- models","text":"flask1.1python3.7 Flask-SQLalchemy flask的ORM模型使用ORM模型的原因当项目越来越大时,会出现很多问题 如果原生SQL较多 重复使用率低 如果你的数据库发生改变 所有的原生SQL就都要修改 写原生SQL的时候 会有安全隐患 ORM：中文件关系对象的映射 使用ORM去操作数据库的时候 不会再去写原生的SQL了 通过把表映射成 类 字段为你的属性 ORM在执行的时候 也会最终转换为 SQL语句 去操作数据库 易用性 使用ORM可以减少重复SQL的概率 写出来的模型也更加的直观清晰 可移植性 ORM支持很多不同的数据库 安装sudo pop3 install flask-sqlalchemy 一、执行原生SQL 创建数据库create datebase if not exists 库名 character set utf8 安装pymysqlsudo pip3 install pymysql 配置数据库SQLALCHEMY_DATABASE_URI = ‘mysql+pymysql://用户名:密码@主机:端口号/库名’ 实例（从对象中读取配置） 1234567891011121314151617`config.py`class Config(object): '''项目的应用配置类''' DEBUG = True # SQLALCHEMY_DATABASE_URI = \"mysql://root:1234@192.168.31.180:3306/dy\" SQLALCHEMY_TRACK_MODIFICATIONS = False SECRET_KEY = \"DylqFbqxp5ArVPmzd1D/DuhSIszWjtzTxL4LUktID7mvsb6s75ENhRTbZUBikRqV/vPPmUrF4yvuEruzs/K+/A==\" SQLALCHEMY_COMMIT_ON_TEARDOWN = True# 产品线上使用：class Config_Project(Config): DEBUG = False SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/dyinfo?charset=UTF8MB4\"# 线下环境使用class Config_Devlopement(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:89974037zxc@localhost:3306/HelloFlask?charset=UTF8MB4\"config_dict = {'product': Config_Project, 'develop': Config_Devlopement} 123`manage.py`app = Flask(__name__)app.config.from_object(config_dict['develop']) 当前字段类型 类型名 说明 integer 整形 SmallInteger 小整形 BigInteger 长整型 Float 浮点型 String varchar类型 Text 长文本 Boolean tingint Date 日期 datetime.date Time 时间 datetime.time DateTime 时间和日期 datetime.datetime 约束条件 选项 选项说明 primary_key 主键 默认False index 常规 默认 False Unique 唯一 默认 False nullable 是否为null 默认True default 默认值 注意其中的default默认值 并不是更改表结构的默认值 而是在插入数据的时候 如果不插入数据 则插入默认值 实例配置1234567from flask import Flaskfrom flask_script import Managerfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)# app中间配置在上个代码块有写db = SQLAlchemy(app)manager = Manager(app) 创建模型12345class User(db.Model): id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') 数据的添加修改删除123456789101112131415161718# 创建蓝图，目的是把一个应用分解成一个蓝图的集合MainView = Blueprint('bp',__name__)PetView = Blueprint('pet',__name__)@MainView.route('/createdb')def create_table(): db.drop_all() # 删除与当前模型类同名的表 db.create_all() # 创建当前模型类的表 return '表创建成功'@MainView.route('/adduser/&lt;string:name&gt;')def adduser(name): user = User() user.username = name user.save() return f'添加成功username={name}' 目录结构树123456789101112131415161718192021222324project/ App/ __init__.py static/ js/ img/ upload/ css/ templates/ common/ ... forms/ __init__.py ... models/ __init__.py views/ __init.py__.py ... settings.py email.py extensions.py manager.py migrations/ 三、数据的操作创建模型类12345678910class User(Base,db.Model): __tablename__ = 'user' #给表起名 id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') def __init__(self,username='',age=0,icon='default.jpg'): self.username = username self.age = age self.icon = icon 添加 add add_all添加一条123456@main.route('/add/')def add(): u = User(username='张三',age=18) db.session.add(u) db.session.commit() return '数据添加一条成功' 添加多条1234567@main.route('/add_all/')def add_all(): u1 = User(username='李四',age=20) u2 = User(username='王五',age=22) db.session.add_all([u1,u2]) db.session.commit() return '添加多条' 自定义增删改查的基础类1234567891011121314151617181920212223class Base: # 定义一个添加一条数据的方法 def save(self): try: db.session.add(self) db.session.commit() except: db.session.rollback() # 定义添加多条数据的方法 @staticmethod def save_all(*args): try: db.session.add_all(args) db.session.commit() except: db.session.rollback() # 自定义删除方法 def delete(self): try: db.session.delete(self) db.session.commit() except: db.session.rollback() 四、数据库操作查询集查询数据的集合 分类 原始查询集 类名.query得到的结果就为原始查询集 数据查询集加上各种的过滤器的方法 最终返回的结果 为数据查询集 都是用数据查询集 过滤器all查询所有 以列表形式返回 不支持连贯操作类名.query.all() 12345@main.route('/all/')def all(): data = User.query.all() print(data) return xxx filter()过滤 返回的是sql语句 需要.all/.first一下 类名.query.filter([类名.属性名 条件操作符 值]) 默认返回所有，支持连贯操作 123# data = User.query.filter() #返回所有# data = User.query.filter(User.age&gt;20) #查询年龄大于20的数据data = User.query.filter(User.age&gt;20,User.age&lt;40) #查询年龄大于20的数据 and 小于40 filter_by只支持参数为关键字参数（）123# data = User.query.filter_by(id=2)# data = User.query.filter_by(id&gt;2) #错误写法data = User.query.filter_by(id=2,age=27) offset和limit组合使用类似分页 12data = User.query.offset(2).limit(2)# limit 2,2 order_by()排序12# data = User.query.order_by(User.age) #升序data = User.query.order_by(-User.age) #降序 get获取id对应的数据查询成功返回对象 查询失败 返回None 1data = User.query.get(2) 过滤条件1234# contains包含data = User.query.filter(User.username.contains('7'))# like模糊查询data = User.query.filter(User.username.like('%6')) #以6作为结尾的数据 startswith endswith 以…开头 以…结尾1data = User.query.filter(User.username.endswith('6')) in和not in1data = User.query.filter(~User.age.in_([27,12,1,30,40,50])) 参考: [https://segmentfault.com/a/1190000015240882]参考: [http://docs.jinkan.org/docs/flask/blueprints.html]","link":"/2020/05/19/flask%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"macOS上值得推荐的常用软件","text":"Author: Wee Chou@E-mail: saioukbed@qq.com Note:转载请注明本文出处链接、作者 以下所推荐的 Apps &amp; 服务，都是十分挑剔的本人在使用过许多同类应用后，所筛选出来的自认为真正可以改善生活品质或工作效率的应用 pap.er Pap.er 是一款专门为 macOS 设计的精美壁纸应用，每天更新全球最新高清壁纸；适合喜欢寻找壁纸来改变心情的你。 为什么推荐? 每天更新来自全球的高清(4k,5k)壁纸。 便捷预览壁纸功能：通过缩略图可预览壁纸，能够快速浏览众多壁纸。 强大的即用即设壁纸功能：看到喜欢的壁纸，一键就能设置成为当前桌面壁纸。 壁纸管理便捷：下载过的壁纸，我们贴心的存放到了下载目录，通过应用内直接打开就可以管理。 无广告！无广告！无广告！ =====(づ′▽`)づ ===== IINA IINA 基于 mpv，为最新 Mac 系统而生，支持 Touch Bar、兼容 MPV 脚本、几乎支持所有格式、网络播放，是一款拥有优雅外观的视频播放器。 为什么推荐? 更快和更稳定的解码效果 丰富的设置项 0.25x~16x变速 支持dark mode 免费 开源 无广告 =====(づ′▽`)づ===== Alfred Alfred 这是一款被称之为Mac效率神器的App，有了Alfred 你甚至无需鼠标就可以实现各种操作，包括出发各种文件、网络操作，其UI界面使用方便，而且不是通过命令来实现，是开发者们和键盘刘童鞋们的神器，比之此前类似的软件——Pack和Power来说完全是秒杀的节奏。 应用介绍 这是最基本的了，option+空格激活以后，输入关键字就开始搜索，默认会匹配已经安装的应用软件，我还设置了搜索Safari书签。如果无法匹配，那么会出现搜索google之类的选项，直接触发打开浏览器到搜索引擎搜索。 和Spotlight直接搜索各种类型不同，Alfred要多敲一个空格或者单引号来指示它搜索文件名。实际使用中，我觉得这样更方便和快捷，alfred几乎是秒出结果，而spotlight在迅速反馈结果的同时，有个逐步增加的过程。就对文件的实际搜索效果来说，alfred对文件名的模糊搜索是OK的，但不如Devonthink连文件内容一概通杀的彪悍。当然，DT的彪悍也是在你索引以后的结果，各有专长吧。Spotlight感觉居中，支持文件内容搜索，但仍然不如DT彻底。顺便说一句，DT这几天在促销，可以看这里。 估计键盘流里很多是所谓geek吧，所以alfred支持直接一个“&gt;”后，打开终端执行命令行。 alfred还贴心的支持了和1password的整合。 强力功能需付费!","link":"/2020/05/12/macOSapps/"},{"title":"promise与异步编程","text":"","link":"/2020/08/18/promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"title":"事件模型","text":"原始事件模型（DOM0级） 这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件： 在html代码中直接指定属性值： 1&lt;button id=\"demo\" type=\"button\" onclick=\"doSomeTing()\" /&gt; 在js代码中为: 1document.getElementsById(\"demo\").onclick = doSomeTing(); 优点：所有浏览器都兼容 缺点：1）逻辑与显示没有分离；2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。 因为这些缺点，虽然原始事件类型兼容所有浏览器，但仍不推荐使用。 DOM2事件模型 此模型是W3C制定的标准模型，现代浏览器（IE6~8除外）都已经遵循这个规范。W3C制定的事件模型中，一次事件的发生包含三个过程： 1.事件捕获阶段2.事件目标阶段3.事件冒泡阶段 如下图所示: &nbsp;IE 5.5: div -&gt; body -&gt; document &nbsp;IE 6.0: div -&gt; body -&gt; html -&gt; document &nbsp;Mozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window &nbsp;&nbsp;&nbsp;&nbsp;所有的事件类型都会经历事件捕获但是只有部分事件会经历事件冒泡阶段,例如submit事件就不会被冒泡。 事件的传播是可以阻止的： 在W3c中，使用stopPropagation（）方法 在IE下设置eve.cancelBubble = true；在捕获的过程中stopPropagation（）；后，后面的冒泡过程就不会发生了。 标准的事件监听器该如何绑定： &nbsp;&nbsp;&nbsp;&nbsp;addEventListener(“eventType”,”handler”,”true|false”);其中eventType指事件类型，注意不要加’on’前缀，与IE下不同。第二个参数是处理函数，第三个即用来指定是否在捕获阶段进行处理，一般设为false来与IE保持一致(默认设置)，除非你有特殊的逻辑需求。监听器的解除也类似：removeEventListner(“eventType”,”handler”,”true!false”); 事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。 摘自: [https://www.cnblogs.com/leftJS/p/10948138.html]","link":"/2020/08/11/%E4%BA%8B%E4%BB%B6/"},{"title":"函数的作用域、作用域链以及return关键字","text":"作用域全局作用域：在函数外部使用var关键字定义的变量局部作用域：在函数内部使用var关键字定义的变量 特点： 局部变量无法直接影响全局变量 在局部作用域中可以使用全局作用域的变量 作用域链函数内部变量在进行查询时，遵循的规则： 首先从函数自身所在的作用域进行查找 若没有，则向父级或者是先辈作用域进行查找 若没有，最终的值就是undefined 局部变量影响全局变量的方法 在函数内部不使用var关键字定义变量 使用return关键字将局部变量的值返回到函数外部，必须使用对应的变量进行接收 return关键字作用 将函数内部变量的值返回到函数外部 return关键字后面的程序不再执行 转载自: [https://www.cnblogs.com/sherryStudy/p/function_field.html]","link":"/2020/08/10/%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%BB%A5%E5%8F%8Areturn%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"使用react-saga","text":"redux-saga是一个Redux中间件，我在日常的开发中，将它作为发送异步请求的组件。 我认为它的根本作用是降低耦合度，因为在生命周期函数中我们同样可以发送并接受异步请求/结果 用户发出Action，Reducer计算出新的state，view重新渲染。像这样立即算出state的是同步的操作。 redux中的数据流大致是： UI——&gt;action(plain)——&gt;reducer——&gt;state——&gt;UI\\ redux遵循函数式编程的规则，上述的数据流中，action是一个原始js对象(plain object)且reducer是一个纯函数，对于同步且没有副作用的操作，上述的数据流起到可以管理数据，从而控制视图层更新的目的。 但是如果存在副作用，比如ajax异步请求等等，那么应该怎么做？\\ 如果存在副作用函数，那么我们需要首先处理副作用函数，然后生成原始的js对象。如何处理副作用操作，在redux中选择在发出action，到reducer处理函数之间使用中间件处理副作用\\。 redux增加中间件处理副作用后的数据流大致如下： UI——&gt;action(side function)——&gt;middleware——&gt;action(plain)——&gt;reducer——&gt;state——&gt;UI\\ 在有副作用的action和原始的action之间增加中间件处理，中间件的作用就是：转换异步操作，生成原始的action，这样，reducer函数就能处理相应的action，从而改变state，更新UI。\\ redux-saga的基本使用 配置中间件 src/store/index.js 123456789101112131415import { createStore, applyMiddleware } from 'redux'import reducer from './reducer'import createSagaMiddleware from 'redux-saga'import rootSaga from './saga'const sagaMiddleware = createSagaMiddleware() // 创建中间件export const store = createStore( reducer, // 挂载 applyMiddleware(sagaMiddleware))// 执行sagaMiddleware.run(rootSaga) saga.js src/store/saga.js 123456789101112131415161718192021222324252627282930313233343536import { call, put, takeEvery } from 'redux-saga/effects'// 用于存放action type 常量import { GET_HOME_LIST } from '../pages/home/store/contants'// function* 生成器函数，他将返回一个Generator对象function* getHomeList(action) { // fetch是ES6提供的原生方法 const p = () =&gt; fetch([your url],{ method: 'GET' }) // 比axios多了这一步 .then(res=&gt; res.json()) .then(res=&gt;{ if (res.success) { return res.data }else { console.log('网络请求失败') } }) // 用call接受p异步函数返回的结果 const res = yield call(p) // 触发success action并带上异步结果 yield put({ type: GET_HOME_LIST_SUCCESS, payload: res })}function* rootSage() { // getHomeList指上面的getHomeList生成器函数 yield takeEvery(GET_HOME_LIST, getHomeList)}export default rootSage 3.reducer.js src/store/reducer.js 12345678910export default (state = defaultState, action) =&gt; { switch (action.type) { case GET_HOME_LIST_SUCCESS: // do something // 将接收到的action.payload进行一系列操作，并拼接到state中 return state default: return state }} 最初的action由UI组件发起 12345678910111213141516171819202122import { connect } from 'react-redux'import { getMoreHomeList } from '../store/actionCreator'//省略JSX部分...// 以下使用react-redux映射（同步）state、dispatch，使结构更清晰，降低耦合度// 将redux的state映射到this.props中const mapState = state =&gt; ({ articleList: state.getIn(['home', 'articleList']), loading: state.getIn(['home', 'loading'])})// 将redux的store.dispatch映射到this.props中const mapDispatch = dipatch =&gt; ({ handleLoadMore(e) { e.preventDefault() // 通过dispatch发送action dipatch(getMoreHomeList()) }})export default connect(mapState, mapDispatch)(List); 通过上述章节，我们可以概括出redux-saga做为redux中间件的全部优点： 统一action的形式，在redux-saga中，从UI中dispatch的action为原始对象 集中处理异步等存在副作用的逻辑 通过转化effects函数，可以方便进行单元测试 完善和严谨的流程控制，可以较为清晰的控制复杂的逻辑。 参考:[https://www.jianshu.com/p/05b73d826425]","link":"/2020/09/15/%E4%BD%BF%E7%94%A8react-saga/"},{"title":"初探Nuxtjs","text":"在我大致阅读完Vue的官方文档后，觉得不够过瘾，正好文档中有提到Nuxt，出于好奇，我打开了Nuxt的官方文档。 什么是NuxtJS简而言之，Nuxt是运行在node环境的SSR（服务端渲染）框架，且基于Vue。Vue负责开发多页应用，Nuxt在此之上再做拓展，可以直接用命令生成完整的html页面，在服务器端完成渲染。 什么是SSR在认识SSR之前，首先对CSR与SSR之间做个对比。 首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接HTML字符串（模板），通过一系列的数据处理之后，把整理好的HTML返回给客户端,浏览器相当于打开了一个页面。这种比如我们经常听说过的jsp,PHP,aspx也就是传统的MVC的开发。 SPA应用，到了Vue、React，单页面应用优秀的用户体验，逐渐成为了主流，页面整体式javaScript渲染出来的，称之为客户端渲染（CSR）。SPA渲染过程。由客户端访问URL发送请求到服务端，返回HTML结构（但是SPA的返回的HTML结构是非常的小的，只有一个基本的结构，如第一段代码所示）。客户端接收到返回结果之后，在客户端开始渲染HTML，渲染时执行对应javaScript，最后渲染template，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回json格式数据。客户端接收数据，然后完成最终渲染。 SPA虽然给服务器减轻了压力，但是也是有缺点的： 首屏渲染时间比较长：必须等待JavaScript加载完毕，并且执行完毕，才能渲染出首屏。SEO不友好：爬虫只能拿到一个div元素，认为页面是空的，不利于SEO。为了解决如上两个问题，出现了SSR解决方案，后端渲染出首屏的DOM结构返回，前端拿到内容带上首屏，后续的页面操作，再用单页面路由和渲染，称之为服务端渲染(SSR)。 SSR渲染流程是这样的，客户端发送URL请求到服务端，服务端读取对应的url的模板信息，在服务端做出html和数据的渲染，渲染完成之后返回html结构，客户端这时拿到的之后首屏页面的html结构。所以用户在浏览首屏的时候速度会很快，因为客户端不需要再次发送ajax请求。并不是做了SSR我们的页面就不属于SPA应用了，它仍然是一个独立的spa应用。 SSR是处于CSR与SPA应用之间的一个折中的方案，在渲染首屏的时候在服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在服务端接收到请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给客户端去渲染其他路由的页面。 via掘金:LuSir63227 Nuxt.js的特点（优点）： 基于Vue 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 EcmaScript6和EcmaScript7的语法支持 打包和压缩JavaScript和CSS HTML头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式预编译器SASS、LESS等等 支持HTTP/2推送 Nuxt环境搭建安装依赖开始之前需要先安装node，且版本大于8.9.0，下面是链接 https://nodejs.org/en/download/（建议安装LTS的最新版本） 从零构建创建项目文件夹，将工作目录切换到项目文件夹 12mkdir &lt;project-name&gt;cd &lt;project-name&gt; 然后创建依赖管理文件 1touch package.json 打开package.json，编辑基本信息 123456789{ \"name\": \"my-app\", \"scripts\": { \"dev\": \"nuxt\", \"build\": \"nuxt build\", \"generate\": \"nuxt generate\", \"start\": \"nuxt start\" }} 安装Nuxt一旦package.json被创建了，我们就可以通过包管理工具安装依赖，这里我们使用npm 1npm install nuxt 随后nuxt会被添加到package.json中，并自动生成node_modules文件夹 创建第一个页面在项目工作目录下： mkdir pagestouch pages/index.vue 该组件将作为默认页面的内容显示接下来为组件加入内容 123&lt;template&gt; &lt;h1&gt;Hello world!&lt;/h1&gt;&lt;template&gt; 启动服务在终端输入npm run dev命令，就会在本地http://localhost:3000 路由与单纯使用vue不同，nuxt对vue的路由进行了封装，依据pages的目录结构，nuxt会自动生成vue-router模块的路由配置 假设 pages的目录如下 └─pages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─index.vue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─index.vue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─one.vue 则Nuxt.js自动生成的路由配置如下： 12345678910111213141516171819router: { routes: [ { name: 'index', path: '/', component: 'pages/index.vue' }, { name: 'user', path: '/user', component: 'pages/user/index.vue' }, { name: 'user-one', path: '/user/one', component: 'pages/user/one.vue' } ]}","link":"/2020/08/27/%E5%88%9D%E6%8E%A2Nuxtjs/"},{"title":"前端杂谈","text":"Recorder: Wee Chou z-index仅同级Element有效,父子关系只需修改子元素 npm init –yes 生成package.js 且全部选yes选项 **Element.closest()** 方法用来获取：匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。 很重要!!!!在事件委托上很常用 getBoundingClientRect() 获取坐标， 当元素没有left top值时，通过获取坐标来获取位置参数。 很重要！！！！ element.insertAdjacentHTML(position, text) 回流必将引起重绘, 而重绘不一定会引起回流(回流: 改变元素的布局或尺寸…;重绘: 仅改变元素的外观,不会影响布局) 基线总是与行内高度最高的元素一致的 边缘折叠,两个边距中较小的边距被较大的边距所取代 负页边距确实会对垂直格式产生影响，并影响页边距的折叠方式 vertical-align 改变基线的位置 display: grid; 网格布局 很好用 CSS中脱离文档流，bai也就是将元素从普通的布局排版中拿走，其他盒zhi子在定位的时候，会当做脱dao离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。 这个用于视口的meta标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。 多列布局: column-width: 12em; column-width: 4(固定列数,宽度可变) 善于利用calc设定尺寸 -&gt; 例如 calc(50% - 10px) 不能从dispaly:none 开始过渡, 因为还没开始”绘制” 递归 {需要有个结尾} like return 0; 使用原型是为了共享属性和方法 所有引用类型都继承了Object","link":"/2020/08/06/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%B0%88/"},{"title":"原型模式","text":"什么是原型?我们创建的每个函数都有一个 prototype 属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。若按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的对象实例的原型对象。 原型是 Javascript 中的继承的基础，JavaScript 的继承就是基于原型的继承。 使用原型的好处？使用原型的好处是可以让所有对象实例共享属性和方法，而不用多次构建相同的属性或方法，占用多余的内存。 举一个最简单的例子： 123456789function Person() {}Person.prototype.name = \"wee\"; // 在Person原型中设定name属性var person1 = new Person();var person2 = new Person();console.log(person1.name);console.log(person2.name); // 两个同类但不同的实例都能从其原型中访问到name 创建实例对象最好的办法，是结合构造函数模式和原型模式。使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 1234567891011121314function SuperType(name) { this.name = name; this.colors = ['red','purple'];}SuperType.prototype.sayName = function() { console.log(this.name)}function SubType(name, age) { SuperType.call(this, name); // 继承属性,目的是为了让this指向SubType实例对象,使SuperType中的this this.age = age;}subType.prototype = new SuperType() // 继承方法var sub = new SubType('wee','')","link":"/2020/08/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"基于Vue-cli2.x的项目构建流程","text":"记录使用vue-cli脚手架项目构建流程 &amp;&amp; Debug过程 Author: wee chou 环境参数nodejs &gt;=6.2.2npm &gt;= 3.9vue &gt;= 2.5.2IDE vscodeGitgithub平台账户 安装依赖 vscode 宇宙第一IDE 好用的（前端）插件： Chinese（友好的简体中文界面）ESLint（严格的代码审查）Live Server（在本地搭建临时的微服务器）Vetur（格式化代码） node.js 建议安装较为稳定的 LTS 版本 根据提示安装完成后,通过 node -v 命令校验是否安装成功 Vue CDN:https://cdn.jsdelivr.net/npm/vue/dist/vue.jshttps://unpkg.com/browse/vue@2.6.11/dist/vue.js 脚手架的依赖项包含了vue库，因此可以一步到位，不需要再次引用 Vue-cli 通过npm包管理工具全局安装vue-cli（npm是node的包管理工具，不用再次安装）npm install --global vue-cli 项目构建执行命令 vue init webpack Travel 经过一系列设置后，项目的整体架构就搭建好了 配置方法 别名alias 在使用vue-cli架构时，想要引入外部文件，可以使用语法糖‘@’简写路径，而‘@’代表src文件夹。想要添加自定义路径，可以在build/webpack.base.conf.js文件中进行设置 1234567resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), }}, 常见问题 less和less-loader版本号不一致 开发中想要用less添加样式，于是在终端安装依赖： &nbsp;&nbsp;npm install less less-loader --save 提示安装成功，在使用过程中却报了许多错误信息，通过查阅资料得知是因为less和less-loader版本号不一致。解决办法也很简单，卸载之前的less-loader，用添加版本号的方式重新安装： &nbsp;&nbsp;npm install less-loader@3 --save","link":"/2020/08/21/%E5%9F%BA%E4%BA%8EVue-cli2-x%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"title":"基于Vue-cli3.x的项目构建流程","text":"","link":"/2020/08/25/%E5%9F%BA%E4%BA%8EVue-cli3-x%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"基于 vite4 + vue3 + TS 从零搭建一个组件库","text":"目录 基于 vite + vue3 + ts 的组件库，意于巩固相关知识点 vite支持ts： https://blog.csdn.net/u012961419/article/details/110520129 1. 官网搭建vite官方文档：https://vitejs.dev/ 1.1. 创建项目使用脚手架构建项目并自定义配置（这里使用yarn，也可以使用你喜欢的其他包管理工具） 1yarn create vite 或者跳过自定义配置阶段，直接构建项目 12# yarnyarn create vite my-vue-app --template vue 1.2. 安装依赖123yarn# oryarn install 1.3. 启动项目1yarn run dev 服务启动之后，访问对应的url地址就能看到效果啦 （初始页面这里建议我们搭配Volar插件进行开发） 1.4. 环境配置1.4.1 补充类型声明在初始化项目后，可以看到项目成功跑起来了，但回到代码当中，却发现 因为在ts项目当中，.ts文件是无法识别.vue文件的，所以我们需要创建.d.ts文件并在其中添加报错相应的声明（.d.ts文件在项目中放置的位置需要与tsconfig.json中include属性声明.d.ts的文件路径同步，否则依然会报错） 像这样声明之后，对应的红色波浪线报错就会消失了 2. 对页面进行初步搭建2.1 顶部菜单栏这里我们需要安装vue-router，实现路由切换 1yarn add vue-router@4 2.2 创建顶部导航栏，首页以及文档页顶部导航栏 1234567&lt;!-- 顶部导航栏 --&gt;&lt;template&gt; &lt;div id=&quot;navBar&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/doc&quot;&gt;文档&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; doc文档页 1234&lt;!-- 文档页 --&gt;&lt;template&gt; &lt;div&gt;doc&lt;/div&gt;&lt;/template&gt; home首页 1234&lt;!-- 首页 --&gt;&lt;template&gt; &lt;div&gt;home&lt;/div&gt;&lt;/template&gt; 2.3路由配置单独维护路由配置，降低耦合度 123456789101112131415import { createRouter, createWebHashHistory } from 'vue-router'import Home from '@/components/home.vue'import Doc from '@/components/doc.vue'const routes = [ { path: '/', component: Home }, { path: '/doc', component: Doc }]const router = createRouter({ history: createWebHashHistory(), routes})export default router main.ts 12345678910import { createApp } from 'vue'import App from './App.vue'import Router from './router'import './assets/normalize.css'const app = createApp(App)// 挂载路由app.use(Router)app.mount('#app') 3. 封装按钮组件4.创建文档页介绍组件4.1. 安装vite-plugin-markdown有了它你可以在vite项目中导入并使用Markdown文件 1yarn add vite-plugin-markdown --dev 4.2.封装Markdown组件123456789101112&lt;template&gt; &lt;article class=&quot;markdown&quot; v-html=&quot;content&quot;&gt;&lt;/article&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;const props = defineProps({ content: { type: String, default: '' }})&lt;/script&gt; 4.3 新增类型声明新增 *.md类型声明，否则ts文件不认识md文件 （这里对声明文件做个解释补充：由于ts是强类型语言，在编译过程中会检查是否对各个变量声明类型，如果遇到没有声明类型的变量会有【缺少类型】的报错，所以我们需要在.d.ts声明文件中添加未被记录的类型声明） 1234declare module '*.md' { const html: String export { html }} 4.3.1 新增文档页子路由123456789101112131415161718192021// index.tsimport { createRouter, createWebHashHistory } from 'vue-router'import Home from '@/views/home/index.vue'import Doc from '@/views/doc/index.vue'import docRouters from './doc-routers'const routes = [ { path: '/', component: Home }, { path: '/doc', component: Doc, children: docRouters }]const router = createRouter({ history: createWebHashHistory(), routes})export default router 123456789101112131415161718192021// doc-routers.tsimport { h } from 'vue'import Button from '@/views/doc/button/index.vue'import Markdown from '@/components/Markdown.vue'const md = (html: any) =&gt; h(Markdown, { content: html })import { html as Intro } from '../markdown/intro.md'const IntroDoc = md(Intro)const routes = [ { path: 'intro', component: IntroDoc }, { path: 'button', component: Button }]export default routes 5. 代码块展示功能5.1. 自定义插件vue-custom-blocks-plugin12345678910111213141516171819202122232425262728// TODO注释import fs from \"fs\";import { baseParse } from \"@vue/compiler-core\";const vitePluginVue = { name: \"preview\", transform(code, id) { // 每个被插件跟踪到的文件都会执行一遍 if ( !/\\/src\\/views\\/doc\\/.*\\.preview\\.vue/.test(id) || !/vue&amp;type=preview/.test(id) ) { return; } let path = `.${id.match(/\\/src\\/views\\/doc\\/.*\\.preview\\.vue/)[0]}`; const file = fs.readFileSync(path).toString(); // 用于读取preview标签中的内容，作为title const parsed = baseParse(file).children.find((n) =&gt; n.tag === \"preview\"); const title = parsed.children[0].content; const main = file.split(parsed.loc.source).join(\"\").trim(); return `export default function (Component) { Component.__sourceCode = ${JSON.stringify(main)} Component.__sourceCodeTitle = ${JSON.stringify(title)} }`.trim(); },};export default vitePluginVue; 5.2. 将插件挂载到vite.config.ts123456import vitePluginVue from './plugins/vue-custom-blocks-plugin'export default defineConfig({ plugins: [vue(), mdPlugin({ mode: [Mode.HTML] }), vitePluginVue], ...}) 5.3. 效果展示 6. 发布到npm6.1. 安装rollup 这里用其他打包工具也行，因为只是上传组件库所以采用rollup，比较轻量 12# 我这里选择全局安装，也可以局部安装npm install rollup -g 6.2. 配置rollup.config.js6.2.1. 安装相关依赖 rollup-plugin-esbuild：将ts编译成ES6 @vitejs/plugin-vue rollup-plugin-scss：转译scss文件 rollup-plugin-terser：代码压缩插件，转译es6+语法 123456789101112131415161718192021222324252627282930import esbuild from 'rollup-plugin-esbuild'import vue from '@vitejs/plugin-vue'import scss from 'rollup-plugin-scss'import DartScss from 'sass'import { terser } from 'rollup-plugin-terser'export default { input: 'src/lib/index.ts', // 入口文件地址 output: { globals: { vue: 'Vue' // 指明global.Vue即是外部依赖vue }, name: 'wee-ui', file: 'dist/lib/wee-ui.js', format: 'umd', plugins: [terser()] }, plugins: [ scss({ include: /.scss$/, fileName: 'wee-ui.css' }), vue({ include: /.vue$/ }), esbuild({ include: /.[jt]s$/, minify: process.env.NODE_ENV === 'production', target: 'es2015' }) ], external: ['vue']} 6.3. 执行打包命令1rollup -c 6.3.1. 打包结果 6.4. 发布6.4.1. 注册一个npm账号官网注册即可：https://www.npmjs.com/ 6.4.2. 登录npm在登录之前，需要保证当前的npm源是官方源，否则无法成功登录 12npm config get registrynpm config set registry registry.npmjs.org 在项目终端执行 1npm login 之后会提示你输入用户名、密码、邮箱，还会向邮箱发送一个验证码，用于最后的身份验证，登录成功后会有提示 6.4.3. 最终发布最后在发布之前，需要确认包的相关描述内容 name：npm包名 private：如果我们发布的是public包，需要将该属性改成false，不然无法成功发布 version：版本名（每次发布需要保证当前版本不同于线上的版本，否则会冲突） description：项目描述 files：要发布的内容 12345678910{ \"name\": \"kuma-ui\", \"private\": false, \"version\": \"0.0.1\", \"description\": \"kuma UI 组件库\", \"files\": [ \"dist/lib/*\" ], ...} 执行发布命令  1npm publish 发布成功后，我们就能在其他项目中使用我们自己的组件库啦，完善后还可以供其他开发者使用","link":"/2023/02/13/%E5%9F%BA%E4%BA%8E-vite4-vue3-TS-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"title":"常见算法","text":"&nbsp;&nbsp;&nbsp;&nbsp;今年算法接触得比较少，更多的是在钻研如何把业务代码写得更加完善，提高项目的健壮性和扩展性。前段时间发现自己在算法上有很大的提升空间，所以最近计划每天在leetcode上刷刷题，想让自己保持一定的逻辑能力。 求最大公约数123function gcd (a, b) { return b === 0 ? a : gcd(b, a % b)}","link":"/2020/12/29/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"},{"title":"快速构建React单页应用","text":"习惯了Vue的开发模式，想尝试一下更加低粒度的React框架。 开发环境 node LTS latest VScode Create React App对于React初学者来说（比如此刻的我），快速构建应用无非省去了很多准备工作，从而提高开发效率。利用Create React App可以快速构建一个React单页应用，只需在终端执行下列命令。 &nbsp;&nbsp;npx create-react-app my-app &nbsp;&nbsp;cd my-app &nbsp;&nbsp;npm start 注意第一行的 npx 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。","link":"/2020/09/02/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"},{"title":"理解async&#x2F;await","text":"async/await是ES7中新增的语法糖，可以使JavaScript的异步操作（IO操作，对资源的操作，读文件，发送http请求，操作数据库）开发更加简洁 在理解asycn/await是什么之前，我们需要理解什么是Promise例如使用jquery中的Ajax，想要获取从服务端传来的返回值，我们往往会这么做 12345678910111213$.ajax({ url: 'json.php', type: 'get', // 设置的是请求参数 data: { id: 1, name: '张三' }, // 用于设置响应体的类型 注意 跟 data 参数没关系 dataType: 'json', success: function (res) { // 一旦设置的 dataType 选项，就不再关心 服务端 响应的 Content-Type 了 // 客户端会主观认为服务端返回的就是 JSON 格式的字符串 console.log(res) }}) 其中success对应的函数就是回调函数，我们可以用回调函数获取异步操作的结果 123456789101112var b = 0function foo(callback) { setTimeout(() =&gt; { b += 1 callback(b) }, 1000);}foo(res=&gt; { console.log(res)})// 1秒后打印 1 这么一看似乎用回调函数就能完美解决问题。但如果我们想要每秒给b加1，并持续3秒该怎么做呢？这时为了维持上下文，我们不得不嵌套回调函数 1234567891011121314151617var b = 0function foo(callback) { setTimeout(() =&gt; { b += 1 callback(b) }, 1000);}foo(() =&gt; { foo(() =&gt; { foo(res =&gt; { console.log(res) }) })})// 3秒后输出3 我们可以看到，照这个趋势下去，如果要获取10秒后的结果，代码会变得非常糟糕。 在ES6中，promise的出现拯救了这样的“回调地狱”。 promise提供了几个基本的api Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 如何使用把上面的例子改成promise 1234567891011121314151617function foo(b = 0) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { b += 1 resolve(b) }, 1000); })}foo().then(res=&gt;{ return foo(res)}).then(res=&gt;{ return foo(res)}).then(res=&gt; { console.log(res)})// 3秒后输出3 虽然代码量没有减少，但代码结构明显变得更加美观，逻辑也更加清晰，更重要的是promise非常灵活，只需要用promise包裹普通函数，若成功则用resolve接受结果，若失败则用reject接受失败信息，再创建promise实例对象，调用then方法使用resolve获取到的参数，调用catch方法使用reject获取到的参数。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 而async/await其实就是配合promise的语法糖12345678910111213141516async function foo() { const b = await after1s() // 相当于 const b = after1s().then(res=&gt;res) // 捕获异常 const b = after1s().catch(error=&gt;error) console.log(b)}function after1s() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(200) }, 1000); })}foo() // 1秒后输出200 用await修饰的对象，若是promise对象，则会默认接收resolve传递过来的resolve值，也就是默认执行了then方法。 （函数内部用了await，函数就必须用async修饰，不然会报错） 用async修饰的函数，其内部运行的任何函数都会被包装成promise对象。 await会阻塞线程（异步的调用变成同步的调用），以axios举例 12 参考：https://www.jianshu.com/p/063f7e490e9a","link":"/2020/09/17/%E7%90%86%E8%A7%A3async-await/"},{"title":"理解虚拟DOM","text":"虚拟DOM并不是什么神奇的东西，它只是用来描述真实DOM的Javascript对象而已。 &nbsp;&nbsp;&nbsp;&nbsp;在传统的前端开发中，我们会大量使用DOM提供的API，直接对DOM进行增删改查一系列操作，然而每进行一次DOM操作，都会使页面重新渲染，相对来讲这是很消耗性能的。因此在前端优化中有一条原则：尽量减少DOM操作。 &nbsp;&nbsp;&nbsp;&nbsp;而虚拟DOM可以作为真实DOM的抽象，有其同等的作用，且更高效。它是一个独立的技术，只不过React使用了这项技术来提高自身性能。 &nbsp;&nbsp;&nbsp;&nbsp;在React的JSX中，每一个标签其实都可以用js来描述，例如以下DOM结构： 123&lt;div className='foo'&gt; &lt;h1&gt;Hello React&lt;/h1&gt;&lt;/div&gt; 可以用这样的javascript对象来描述： 123456789101112{ type: 'div', props: { className: 'foo', children: { type: 'h1', props: { children: 'Hello React' } } }} &nbsp;&nbsp;&nbsp;&nbsp;有了虚拟DOM这一层，当我们需要操作DOM时，就可以操作虚拟DOM，而不操作真实DOM，虚拟DOM是普通的JavaScript对象，访问JavaScript对象当然比访问真实DOM要快得多。到这里，大家可以发现，虚拟DOM并不是什么神奇的东西，它只是用来描述真实DOM的JavaScript对象而已。 \b 参考： 《React 进阶之路》","link":"/2020/10/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM/"},{"title":"用hooks实现Redux","text":"什么是Hook以下是官方解释： Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 在传统的React开发中，我们可以使用Redux提供的组件去监听全局状态，通常需要四个步骤： 用redux中的createStore方法创建store实例，并传入reducer函数（传入state、action，导出state） 由组件调用store.dispatch(action = {type:xxx,value:xxx}) 在reducer中接收action，并根据action.type执行相应操作，最终返回state store更新state后，需要组件在合适位置（通常在constructor中）发布订阅，更新视图:12345678910class A extends Component { constructor() { super() ... store.subscribe(this.updateView) } updateView() { this.setState(store.getState()) }} 那么如何用hooks实现Redux的功能呢 用hooks实现的过程中，也可以看到很多Redux的影子。我将用一个简单的例子展示如何运用hooks实现Redux，该demo划分为四部分： DemoProvider（关键，提供全局服务） Demo（父组件） DemoButton（子组件1） DemoContent（子组件2） DemoProvider.js 1234567891011121314151617181920212223242526272829import React, { createContext, useReducer } from 'react';// React.createContext 提供全局上下文export const ColorContext = createContext({})// 创建动态变量用于设置action.typeexport const UPDATA_COLOR = 'UPDATE_COLOR'// 和Rudex中一样，作为一个独立的模块处理state// 根据dispatch传来的action，执行相应的操作，返回stateconst reducer = (state, action) =&gt; { switch(action.type){ case UPDATA_COLOR: return action.color default: return state }}export const Color = props =&gt; { const [color, dispatch] = useReducer(reducer, 'blue') return ( // Provider组件，用于数据共享 &lt;ColorContext.Provider value={{color, dispatch}}&gt; {/* 表示被包裹的子组件 */} {props.children} &lt;/ColorContext.Provider&gt; )} DemoButton.js 12345678910111213141516import React, { useContext } from 'react';import { ColorContext, UPDATA_COLOR } from './DemoProvider'function Button() { // 从全局上下文中获取dispatch方法 const {dispatch} = useContext(ColorContext) return ( &lt;div&gt; {/* 和Redux中一样，触发dispatch */} &lt;button onClick={()=&gt; {dispatch({type: UPDATA_COLOR, color: 'blue'})}}&gt;be blue&lt;/button&gt; &lt;button onClick={()=&gt; {dispatch({type: UPDATA_COLOR, color: 'red'})}}&gt;be red&lt;/button&gt; &lt;/div&gt; )}export default Button DemoContent.js 1234567891011121314import React, {useContext} from 'react';import {ColorContext} from './DemoProvider'function Content() { // 监听全局上下文的变化（reducer根据action改变state，在此做出响应） let {color} = useContext(ColorContext) return ( &lt;div&gt; &lt;h1 style={{color: color}}&gt;content&lt;/h1&gt; &lt;/div&gt; )}export default Content Demo.js 123456789101112131415161718192021import React from 'react'import Button from './DemoButton'import Content from './DemoContent'// 导入Providerimport {Color} from './DemoProvider'function Demo() { return ( &lt;div&gt; &lt;h1&gt;DEMO&lt;/h1&gt; &lt;hr /&gt; {/* 使用组件 */} &lt;Color&gt; &lt;Content /&gt; &lt;Button /&gt; &lt;/Color&gt; &lt;/div&gt; )}export default Demo 可以看到，无论用hooks还是Redux，目的都是为了创建一个全局状态管理容器，它们的数据流也是一样的：","link":"/2020/09/07/%E7%94%A8hooks%E5%AE%9E%E7%8E%B0react-redux/"},{"title":"解构赋值","text":"什么是解构赋值? 解构（destructuring）是ES6中新增的概念，这是将一个数据结构分解为更小的部分的过程。 某些应用场景中，当我们想要往函数中传入多个参数时，通常会这样做： 123456function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender;}var p1 = new Person('wee', 18, 1); 如果我们只需要一个实例，那并不能看到什么问题。但如果我们想要创建多个实例，而且包含相同的参数，这样无疑增加了代码冗余。 接下来我们尝试一下用对象控制传参数： 12345678910111213var person = { name: 'wee', age: 18, gender: 1}function Person(obj) { this.name = obj.name; this.age = obj.age; this.gender = obj.age;}var p1 = new Person(person);person.name = 'boy';var p2 = new Person(person); 此时，虽然我们可以使用一个对象控制传参了，但构造函数内部的代码量变多了，而且看上去着实不太美观。 那么有没有什么办法可以改善这种情况呢？我们可以使用解构赋值： 12345678910111213var person = { name: 'wee', age: 18, gender: 1}function Person({name, age, gender}) { this.name = name; this.age = age; this.gender = gender;}var p1 = new Person(person);person.name = 'boy';var p2 = new Person(person); 可以看到，我们使用解构，在构造函数内部使用参数之前，针对性地将传入对象“分解”，而不用再在内部逻辑中从对象取值。","link":"/2020/08/18/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"解决React组件样式污染","text":"在我用React写社区项目，利用浏览器开发工具进行调试时，偶然想到了样式污染的问题。在Vue中，我们可以给style标签添加scoped属性，解决样式污染的问题： 每个组件都会被赋予一个唯一的[data-*]属性，CSS也会随之添加对应选择器： 那么在React中，该如何解决类似的问题？网上有许多方法，在此我尝试了其中两种较主流的方法。 1.styled-components 首先我们需要安装它 yarn add styled-components or npm install --save styled-components 举一个简单但能体现特性的例子 123456789101112131415161718192021222324252627import React, { Component, Fragment } from 'react';//引入styled-componentsimport styled from 'styled-components'//修改了div的样式const myTitle = styled.div` font-size: ; color:red;`// 修改了button的样式const Button = styled.button` border:none; background-color:blue;`class App extends Component { render() { return ( // 使用Fragment标签可以仅包裹但不添加额外节点 &lt;Fragment&gt; &lt;Title&gt;标题&lt;/Title&gt; &lt;Button&gt;按钮&lt;/Button&gt; &lt;/Fragment&gt; ) }}export default App; 然后我们就能看到意料之中的结果 同时我们可以看到，styled-components给元素设置了某种规范的并且是随机的className，从而避免了样式污染。 但经过初步使用后，我并不喜欢这种解决方式（大概是因为在js里写css没有代码提示…），于是我开始尝试另一种方法。也是我最后选择的方法，CSS modules。 2.CSS modules使用方法：[https://www.w3cplus.com/react/css-modules-in-react.html] 我按照上述网站的方法进行了一系列配置，最终也得到了正确的结果，但似乎哪里有些差强人意。。。 CSS modules自动生成的className太长了。。。虽然对使用者来说不会有任影响，但对于常用开发者工具的开发者来说，至少对我来说，这实在是太糟糕了。我希望他能只留下最后的hash。然后我翻遍了google/baidu/CSDN/Stack Overflow/React官网/github issues等网站🐵查阅了许多资料，重启了n次服务器，最终还是没能解决问题。在网上看到最多的就是对css-loader中localIdentName属性的设置，但我尝试在各种位置设置，都没有用，于是我逆向查找到了引用这个属性的方法。。。 可以看到，localIdentName是灰色的，这代表在后面的函数体中并没有使用到这个属性，只使用到了localName 接下来就简单了，重新拼接出自己想要的字符串就行了，但这里最好的办法还是先判断是否传入localIdentName，将localName作为默认值，根据if返回结果，我想这也是作者的初衷。 好在最终得到了想要的结果(￣▽￣)~*","link":"/2020/09/09/%E8%A7%A3%E5%86%B3React%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81/"},{"title":"解读关键字&quot;new&quot;","text":"Author: Wee Chou 在new的过程中到底发生了什么？请先看下面的例子： 1234function Person(){}var person0 = Person() // undefinedvar person1 = new Person() // {} 在平日的开发中，我们对函数的调用无非有两种方法： 直接调用 使用new初始化函数 在上述例子中，我们可以很快理解直接调用返回undefined的原因，因为Person函数没有返回值。但为什么new Person()会返回一个空对象？这就涉及到构造函数的知识了。 那么什么是构造函数？ 我们知道Javascript和其他基于类的语言不同，他是基于对象的，在该语言中没有类的概念（ES6中的“类”也只是语法糖）。那么在Javascript中，我们如何创建对象呢。这就用到了构造函数。 123456function Person(name) { this.name = name;}var person = new Person('wee');console.log(person.name); // wee 这就是一个最简单的构造函数。 现在我们又会疑惑，里面的this是什么？ 我们创建对象，就需要结合this和new。 123function A() { //return this;} 其实，当我们使用new初始化一个函数时，函数内部会隐式返回一个this，如果我们把他想象成一个空对象，就很好解释了。 123456function A() { var obj = new Object(); // 在内存中创建一个空对象 return obj;}var a = new A(); // a指向obj 而赋予this属性和方法，其实等同于赋予这个空对象属性和方法。 12345678function A(name) { var obj = new Object(); obj.name = name; return obj;}var a = new A('wee');console.log(a.name); // wee 而这，就是传统的利用工厂模式创建对象。而利用this，就是构造函数模式创建对象。 那么言归正传，new的过程中到底发生了什么? 12345678910111213141516171819202122232425function A(){}function B(){ this.name = 'wee'; return this; // 显式返回}function _new(func){ var obj = new Object(); var result = func.call(obj); // 将this指向obj // 判断此时func的返回值，若为对象，则返回result，否则返回obj var _result = function() { if (typeof result == 'object') { return result; }else { return obj; } } return _result();}// var a = new A();// 等同于console.log(_new(A)); // {}// var b = new B();// 等同于console.log(_new(B)); // {name:'wee'} 我们可以看到，A中没有返回任何对象，通过_new(A)返回了一个空对象；B中返回了一个对象，则最后的返回结果就为该对象。","link":"/2020/08/07/%E8%A7%A3%E8%AF%BB%E5%85%B3%E9%94%AE%E5%AD%97-new/"},{"title":"闭包","text":"Author: Wee chou 什么是闭包?许多开发者会因为“闭包”中的“包”想当然地以为只有被包裹才算闭包，比如函数内部“包”个函数，再在内部函数返回外部函数的局部变量。其实形成闭包的条件很简单。 1234var local = 0;function foo() { local++;} 是的，这就形成了一个闭包。形成闭包的条件： 内部函数访问外部函数参数 下面举一个经典的例子: 1234567891011121314function foo() { var local = 0; // 对于foo来说是局部变量 function bar() { local++; // 对于bar来说是外部变量, 此时访问了外部变量local console.log(local); } return bar; // 返回闭包到全局}var func = foo(); // 全局变量在执行过程中不会被回收(?)func(); // 1func(); // 2func(); // 3 就像这个例子里写的，我认为运用闭包最多的场景，就是隐藏变量，即无法在外部直接修改local。 &nbsp;&nbsp;&nbsp;&nbsp;例子中，唯一可以直接访问到local变量的，只有内部函数bar，当bar执行完毕后，会销毁自身，而bar中的局部作用域会释放到foo中，由于我们在全局引用了foo函数，使foo在执行完毕后并没有被立即销毁，又因为在foo中返回了内部函数bar，使得我们可以在全局持续访问并执行bar的内部操作，并保留foo的局部作用域，直到func不再被访问后被回收。 所以闭包只是一个定义，并不是设计者特意由设计出来的","link":"/2020/08/10/%E9%97%AD%E5%8C%85/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"debounce","slug":"debounce","link":"/tags/debounce/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"redux-saga","slug":"redux-saga","link":"/tags/redux-saga/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"issues","slug":"issues","link":"/tags/issues/"},{"name":"Vue-cli2.x","slug":"Vue-cli2-x","link":"/tags/Vue-cli2-x/"},{"name":"Vue-cli3.x","slug":"Vue-cli3-x","link":"/tags/Vue-cli3-x/"},{"name":"vite","slug":"vite","link":"/tags/vite/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"vdom","slug":"vdom","link":"/tags/vdom/"},{"name":"Diff","slug":"Diff","link":"/tags/Diff/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","link":"/tags/ECMAScript-6/"},{"name":"CSS module","slug":"CSS-module","link":"/tags/CSS-module/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"less-loader","slug":"less-loader","link":"/tags/less-loader/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"new","slug":"new","link":"/tags/new/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Flask","slug":"Flask","link":"/categories/Flask/"},{"name":"ToDoList","slug":"React/ToDoList","link":"/categories/React/ToDoList/"},{"name":"Mac OS","slug":"Mac-OS","link":"/categories/Mac-OS/"},{"name":"防抖","slug":"Javascript/防抖","link":"/categories/Javascript/%E9%98%B2%E6%8A%96/"},{"name":"event","slug":"Javascript/event","link":"/categories/Javascript/event/"},{"name":"作用域","slug":"Javascript/作用域","link":"/categories/Javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"models","slug":"Flask/models","link":"/categories/Flask/models/"},{"name":"redux-saga","slug":"React/redux-saga","link":"/categories/React/redux-saga/"},{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"},{"name":"front end issues","slug":"front-end-issues","link":"/categories/front-end-issues/"},{"name":"原型","slug":"Javascript/原型","link":"/categories/Javascript/%E5%8E%9F%E5%9E%8B/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"应用推荐","slug":"Mac-OS/应用推荐","link":"/categories/Mac-OS/%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Create React App","slug":"React/Create-React-App","link":"/categories/React/Create-React-App/"},{"name":"async","slug":"Javascript/async","link":"/categories/Javascript/async/"},{"name":"虚拟dom","slug":"React/虚拟dom","link":"/categories/React/%E8%99%9A%E6%8B%9Fdom/"},{"name":"Hook","slug":"React/Hook","link":"/categories/React/Hook/"},{"name":"ES6","slug":"Javascript/ES6","link":"/categories/Javascript/ES6/"},{"name":"解决样式污染","slug":"React/解决样式污染","link":"/categories/React/%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E6%B1%A1%E6%9F%93/"},{"name":"new关键字","slug":"Javascript/new关键字","link":"/categories/Javascript/new%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"闭包","slug":"Javascript/闭包","link":"/categories/Javascript/%E9%97%AD%E5%8C%85/"},{"name":"start","slug":"Nuxt/start","link":"/categories/Nuxt/start/"},{"name":"Vue-cli2.x","slug":"Vue/Vue-cli2-x","link":"/categories/Vue/Vue-cli2-x/"},{"name":"Vue-cli3.x","slug":"Vue/Vue-cli3-x","link":"/categories/Vue/Vue-cli3-x/"}]}