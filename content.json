{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"防抖函数","text":"在使用React，实现通过onChange事件修改input.value与state.value值的过程中，发现每次修改值（每按下键盘一次），都会调用onChange对应的方法，而我们往往只需要拿到敲击完键盘最后得到的结果就行了，频繁且多余的请求会消耗不必要的性能。我们可以利用防抖函数解决这一问题。 123456789101112//防抖函数function debounce(fn, ms=500) { let timer = null return function(e) { // 想要访问异步事件属性 e.persist() if(timer!==null) clearTimeout(timer) timer = setTimeout(() =&gt; { fn.apply(this, arguments) }, ms); }} 这样一来，每次监听到事件，会先在全局创建一个定时器，并在事件结束的若干毫秒后，再执行对应方法。 注意事项 每次创建定时器之前，若已经存在timer，为了避免定时器叠加，要清除已存在的定时器 e.persist()的解释: If you want to access the event properties in an asynchronous way, you should call event.persist() on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.中文解释（并非翻译）：如果在react中想异步访问事件属性（如在setTimeout内），应该在是处理事件时调用event.persist()，这会从事件池中移除该合成函数并允许对该合成事件的引用被保留下来。 由于传入的fn会在外部调用，且需要外部的作用域，因此用到apply绑定this：fn.apply(this, arguments)","link":"/2020/09/03/React%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0/"},{"title":"React ToDoList","text":"编写一个ToDoList以巩固知识 index.js （入口文件，渲染页面） 1234567import React from 'react'// 提供DOM特定的方法，及页面渲染import ReactDOM from 'react-dom' // ToDoList 组件import ToDoList from './ToDoList'ReactDOM.render(&lt;ToDoList /&gt;, document.getElementById('root')) ToDoList.js（父组件） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 相当于// import React from 'react'// import {Component} from 'react'import React, {Component} from 'react'// webpack提供的导入语法import './styles.css'import Item from './item';class ToDoList extends Component { constructor (props) { // React中，使用props和state来跟踪变量 super(props) this.state = { inputValue: '', list: ['item1', 'item2'] } } render () { return ( &lt;div&gt; &lt;label htmlFor=\"inputItem\"&gt;inputItem: &lt;/label&gt; &lt;input value={this.state.inputValue} onChange={this.itemChange.bind(this)}/&gt; &lt;button onClick={this.addItem.bind(this)}&gt;click me&lt;/button&gt; &lt;ul&gt; { // 使用map遍历html元素 this.state.list.map((item, index) =&gt; { return ( // 向子组件传递content index delete自定义变量 &lt;Item key={item+index} content={item} index={index} deleteItem={this.deleteItem.bind(this)} /&gt; ) }) } &lt;/ul&gt; &lt;/div&gt; ) } itemChange (event) { // React 需要用setState来改变state，而不能直接改变state this.setState({ inputValue: event.target.value }) } addItem () { this.setState({ // ES6 剩余项语法... 类似解构 list: [...this.state.list, this.state.inputValue] }) } deleteItem (index) { var list = this.state.list list.splice(index, 1) this.setState({ // 相当于list: list list }) }}export default ToDoList Item.js (子组件) 12345678910111213141516171819202122// eslint-disable-next-lineimport React, { Component } from 'react';class Item extends Component { // props用于父子组件出传值 constructor (props) { super(props) // 使render中onClick事件对应方法调用时，this指向当前实例 this.handleClick = this.handleClick.bind(this) } render () { return ( &lt;li onClick={this.handleClick}&gt;{this.props.content}&lt;/li&gt; ) } handleClick () { this.props.deleteItem(this.props.index) console.log(this.props) }}export default Item 第一行的eslint-disable-next-line注释，可以使注释行的下一行不会ESLint检测","link":"/2020/08/26/React_ToDoList/"},{"title":"Flask入门 ---- models","text":"flask1.1python3.7 Flask-SQLalchemy flask的ORM模型使用ORM模型的原因当项目越来越大时,会出现很多问题 如果原生SQL较多 重复使用率低 如果你的数据库发生改变 所有的原生SQL就都要修改 写原生SQL的时候 会有安全隐患 ORM：中文件关系对象的映射 使用ORM去操作数据库的时候 不会再去写原生的SQL了 通过把表映射成 类 字段为你的属性 ORM在执行的时候 也会最终转换为 SQL语句 去操作数据库 易用性 使用ORM可以减少重复SQL的概率 写出来的模型也更加的直观清晰 可移植性 ORM支持很多不同的数据库 安装sudo pop3 install flask-sqlalchemy 一、执行原生SQL 创建数据库create datebase if not exists 库名 character set utf8 安装pymysqlsudo pip3 install pymysql 配置数据库SQLALCHEMY_DATABASE_URI = ‘mysql+pymysql://用户名:密码@主机:端口号/库名’ 实例（从对象中读取配置） 1234567891011121314151617`config.py`class Config(object): '''项目的应用配置类''' DEBUG = True # SQLALCHEMY_DATABASE_URI = \"mysql://root:1234@192.168.31.180:3306/dy\" SQLALCHEMY_TRACK_MODIFICATIONS = False SECRET_KEY = \"DylqFbqxp5ArVPmzd1D/DuhSIszWjtzTxL4LUktID7mvsb6s75ENhRTbZUBikRqV/vPPmUrF4yvuEruzs/K+/A==\" SQLALCHEMY_COMMIT_ON_TEARDOWN = True# 产品线上使用：class Config_Project(Config): DEBUG = False SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/dyinfo?charset=UTF8MB4\"# 线下环境使用class Config_Devlopement(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:89974037zxc@localhost:3306/HelloFlask?charset=UTF8MB4\"config_dict = {'product': Config_Project, 'develop': Config_Devlopement} 123`manage.py`app = Flask(__name__)app.config.from_object(config_dict['develop']) 当前字段类型 类型名 说明 integer 整形 SmallInteger 小整形 BigInteger 长整型 Float 浮点型 String varchar类型 Text 长文本 Boolean tingint Date 日期 datetime.date Time 时间 datetime.time DateTime 时间和日期 datetime.datetime 约束条件 选项 选项说明 primary_key 主键 默认False index 常规 默认 False Unique 唯一 默认 False nullable 是否为null 默认True default 默认值 注意其中的default默认值 并不是更改表结构的默认值 而是在插入数据的时候 如果不插入数据 则插入默认值 实例配置1234567from flask import Flaskfrom flask_script import Managerfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)# app中间配置在上个代码块有写db = SQLAlchemy(app)manager = Manager(app) 创建模型12345class User(db.Model): id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') 数据的添加修改删除123456789101112131415161718# 创建蓝图，目的是把一个应用分解成一个蓝图的集合MainView = Blueprint('bp',__name__)PetView = Blueprint('pet',__name__)@MainView.route('/createdb')def create_table(): db.drop_all() # 删除与当前模型类同名的表 db.create_all() # 创建当前模型类的表 return '表创建成功'@MainView.route('/adduser/&lt;string:name&gt;')def adduser(name): user = User() user.username = name user.save() return f'添加成功username={name}' 目录结构树123456789101112131415161718192021222324project/ App/ __init__.py static/ js/ img/ upload/ css/ templates/ common/ ... forms/ __init__.py ... models/ __init__.py views/ __init.py__.py ... settings.py email.py extensions.py manager.py migrations/ 三、数据的操作创建模型类12345678910class User(Base,db.Model): __tablename__ = 'user' #给表起名 id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') def __init__(self,username='',age=0,icon='default.jpg'): self.username = username self.age = age self.icon = icon 添加 add add_all添加一条123456@main.route('/add/')def add(): u = User(username='张三',age=18) db.session.add(u) db.session.commit() return '数据添加一条成功' 添加多条1234567@main.route('/add_all/')def add_all(): u1 = User(username='李四',age=20) u2 = User(username='王五',age=22) db.session.add_all([u1,u2]) db.session.commit() return '添加多条' 自定义增删改查的基础类1234567891011121314151617181920212223class Base: # 定义一个添加一条数据的方法 def save(self): try: db.session.add(self) db.session.commit() except: db.session.rollback() # 定义添加多条数据的方法 @staticmethod def save_all(*args): try: db.session.add_all(args) db.session.commit() except: db.session.rollback() # 自定义删除方法 def delete(self): try: db.session.delete(self) db.session.commit() except: db.session.rollback() 四、数据库操作查询集查询数据的集合 分类 原始查询集 类名.query得到的结果就为原始查询集 数据查询集加上各种的过滤器的方法 最终返回的结果 为数据查询集 都是用数据查询集 过滤器all查询所有 以列表形式返回 不支持连贯操作类名.query.all() 12345@main.route('/all/')def all(): data = User.query.all() print(data) return xxx filter()过滤 返回的是sql语句 需要.all/.first一下 类名.query.filter([类名.属性名 条件操作符 值]) 默认返回所有，支持连贯操作 123# data = User.query.filter() #返回所有# data = User.query.filter(User.age&gt;20) #查询年龄大于20的数据data = User.query.filter(User.age&gt;20,User.age&lt;40) #查询年龄大于20的数据 and 小于40 filter_by只支持参数为关键字参数（）123# data = User.query.filter_by(id=2)# data = User.query.filter_by(id&gt;2) #错误写法data = User.query.filter_by(id=2,age=27) offset和limit组合使用类似分页 12data = User.query.offset(2).limit(2)# limit 2,2 order_by()排序12# data = User.query.order_by(User.age) #升序data = User.query.order_by(-User.age) #降序 get获取id对应的数据查询成功返回对象 查询失败 返回None 1data = User.query.get(2) 过滤条件1234# contains包含data = User.query.filter(User.username.contains('7'))# like模糊查询data = User.query.filter(User.username.like('%6')) #以6作为结尾的数据 startswith endswith 以…开头 以…结尾1data = User.query.filter(User.username.endswith('6')) in和not in1data = User.query.filter(~User.age.in_([27,12,1,30,40,50])) 参考: [https://segmentfault.com/a/1190000015240882]参考: [http://docs.jinkan.org/docs/flask/blueprints.html]","link":"/2020/05/19/flask%E5%85%A5%E9%97%A8/"},{"title":"promise与异步编程","text":"","link":"/2020/08/18/promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"title":"webpack知识点巩固","text":"1. 什么是 Webpack？1.1 回答webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。它主要解决的问题是将多个模块（Module）打包成一个或多个文件，并且在这个过程中还支持一些特性，如代码分离、文件压缩等。 我们先将着重点落在 静态模块打包工具 上，为什么是 静态模块打包工具？ 是因为它可以将多个模块（JavaScript 文件、CSS 文件、图片 等）打包成一个或多个静态资源文件。静态资源文件包含了应用程序中的所有依赖关系和逻辑，可以直接在浏览器中加载和运行。 1.2 webpack 打包示例下面我们就来演示一个最简单的 webpack 打包示例： 首先我们创建一个目录，初始化 npm，然后 在本地安装 webpack，接着安装 webpack-cli（注意：此工具用于在命令行中运行 webpack）： mkdir webpack-democd webpack-demonpm init -ynpm install webpack webpack-cli –save-dev复制代码 现在，我们将创建以下目录结构、文件和内容： add.js： export function add(n1, n2) { return n1 + n2; } 复制代码sub.js export function sub(n1, n2) { return n1 - n2; } 复制代码index.js import { add } from &quot;./add&quot;; import { sub } from &quot;./sub&quot;; console.log(add(1, 2)); console.log(sub(1, 2)); 复制代码可以看到，我们做的仅仅定义了两个工具文件 a.js 和 b.js，并在 index.js 中导入并且调用了两个函数。 接着，我们执行 npx webpack 命令进行打包，打包结果如下图所示： 可以这样说，执行 npx webpack，会将我们的脚本 src/index.js 作为 入口起点，也会生成 dist/main.js 作为 输出。Node 8.2/npm 5.2.0 以上版本提供的 npx 命令，可以运行在初次安装的 webpack package 中的 webpack 二进制文件（即 ./node_modules/.bin/webpack）。 1.3 模块在上面的例子中，我们仅仅演示了 es6 的模块化导入导出，事实上除了 import 和 export，webpack 还能够很好地支持多种其他模块语法比如 CommonJS、AMD等 1.4 配置文件在 webpack v4 中，可以无须任何配置，然而大多数项目会需要很复杂的设置，这时候就需要一个配置文件来拯救我们了，因为这比在 terminal(终端) 中手动输入大量命令要高效的多 创建 webpack-demo/webpack.config.js const path = require(‘path’); module.exports = { entry: ‘./src/index.js’, output: { filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;), },};复制代码 执行打包命令 npx webpack --config webpack.config.js。 可以看到生成的新的文件名为 bundle.js 说明我们的配置文件已经生效。 事实上，如果 webpack.config.js 存在，则 webpack 命令将默认选择使用它，所以我们依然可以使用 npx webpack 进行打包。这里使用 --config 选项只是表明可以传递任何名称的配置文件，这对于需要拆分成多个文件的复杂配置是非常有用的。 1.5 npm scripts考虑到用 CLI 这种方式来运行本地的 webpack 副本并不是特别方便，我们可以设置一个快捷方式。调整 package.json 文件，添加一个 npm script： &quot;build&quot;: &quot;webpack&quot; 复制代码现在，可以使用 npm run build 命令，来替代我们之前使用的 npx 命令。注意，使用 npm scripts，我们可以像使用 npx 那样通过模块名引用本地安装的 npm packages。这是大多数基于 npm 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本。 1.6 总结在这一题中，我们使用了一个最简单的案例来解释了 webpack 是什么东西，它的本质就是一个模块化的打包工具，我想大家应该对它的概念都能有一个基本的了解了。 2. Webpack 的核心概念有哪些？Webpack 的核心概念主要包括以下几个： 入口 Entry 输出 Output 加载器 Loader 插件 Plugin 模式 Mode 浏览器兼容性 Browser compatibility 环境 Environment 代码块 Chunk 模块 Module 2.1 入口 Entry入口起点(entry point) 定义 webpack 从哪个文件开始构建依赖关系图，进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 它的默认值是 ./src/index.js，但是我们可以通过在配置文件中配置 entry属性来指定一个（或多个）不同的入口起点。例如： webpack.config.js module.exports = { entry: &apos;./path/to/my/entry/file.js&apos;, }; 复制代码2.2 输出 Outputoutput 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 你可以通过在配置中指定一个 output 字段，来配置这些处理过程： const path = require(&apos;path&apos;); module.exports = { entry: &apos;./path/to/my/entry/file.js&apos;, output: { path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos;, }, }; 复制代码在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。 2.3 加载器 Loaderwebpack 只能理解 JavaScript 和 JSON 文件。loader 的作用就是让让 webpack 能够去处理其他类型的文件，并将它们转换为 JavaScript 文件。 在 webpack 的配置中，loader 有两个属性： test 属性，识别出哪些文件会被转换。 use 属性，定义出在进行转换时，应该使用哪个 loader。 webpack.config.js const path = require(&apos;path&apos;); module.exports = { output: { filename: &apos;my-first-webpack.bundle.js&apos;, }, module: { rules: [{ test: /\\.txt$/, use: &apos;raw-loader&apos; }], }, }; 复制代码以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 '.txt' 的路径」时，在你对它打包之前，先 use(使用) raw-loader 转换一下。” 2.4 插件 Pluginwebpack 中 loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。插件目的在于解决 loader 无法实现的其他事。 想要使用一个插件，只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例。 webpack.config.js const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); const webpack = require(&apos;webpack&apos;); // 用于访问内置插件 module.exports = { module: { rules: [{ test: /\\.txt$/, use: &apos;raw-loader&apos; }], }, plugins: [new HtmlWebpackPlugin({ template: &apos;./src/index.html&apos; })], }; 复制代码在上面的示例中，html-webpack-plugin 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。 2.5 模式 ModeWebpack 有三种模式：development、production 和 none。通过设置不同的模式，可以启用不同的内置优化。 2.6 浏览器兼容性 Browser compatibilityWebpack 支持所有符合 ES5 标准 的浏览器（不支持 IE8 及以下版本）。 2.7 环境 EnvironmentWebpack 5 运行于 Node.js v10.13.0+ 的版本。 2.8 代码块 Chunkchunk 可以理解为 webpack 构建输出的一个文件，通常包含了在构建过程中生成的一些代码块。webpack 将所有相关的模块打包在一起，以此生成一个或多个chunk 。这些 chunk 可以是 JavaScript文件、CSS文件、图片等，也可以是异步加载的代码块。 webpack 将代码分割成多个 chunk 的主要目的是优化应用程序的性能。通过将代码拆分成多个小块，webpack 可以减少初始加载时间，并提高应用程序的性能。 2.9 模块 ModuleWebpack 会将所有的文件都看作一个个模块，每个模块都有自己的依赖关系，Webpack 会根据这些依赖关系构建出一个依赖关系图。 3. 请解释一下 Webpack 的打包原理Webpack 的打包原理可以简单地概括为以下几个步骤： 解析入口文件：Webpack 通过指定的入口文件开始打包，从该文件开始分析和解析整个项目的依赖关系。 依赖分析：Webpack 根据模块之间的依赖关系，递归地分析和收集所有需要打包的模块，包括 JavaScript、CSS、图片等资源文件。 模块转换：Webpack 在解析模块的过程中，会根据不同的模块类型，将它们转换成 JavaScript 代码，以便在浏览器中执行。 生成 Chunk：Webpack 会将所有模块打包成一个或多个 Chunk，每个 Chunk 包含了一组模块，以及这些模块之间的依赖关系。 生成 Bundle：最后，Webpack 会将所有的 Chunk 生成对应的静态资源文件，例如 JavaScript、CSS、图片等，供浏览器加载和执行。 在整个打包过程中，Webpack 提供了很多插件和配置选项，可以帮助我们自定义打包过程，例如代码压缩、分离 CSS 文件、处理图片 等。同时，Webpack 还支持使用各种 Loader 来处理不同类型的模块，例如使用 Babel Loader 来处理 ES6 语法的模块。 3.1 chunk 和 bundle 的区别是什么？chunk：chunk 是 Webpack 打包生成的一个或多个 JavaScript 文件，它包含了一组相关的模块的代码，可以看做是模块的集合。在实际开发中，chunk 可以用于实现代码分割、按需加载、懒加载等功能，从而优化代码的加载和执行，提高应用的性能和用户体验。 bundle：bundle 是 Webpack 打包生成的一个或多个静态资源文件，它包含了所有模块的代码，可以看做是代码的最终打包结果。在实际开发中，bundle 可以用于发布到生产环境，供浏览器加载和执行。 简单来说，chunk 是 Webpack 在打包过程中产生的中间文件，bundle 是最终生成的静态资源文件。在代码分割和按需加载的场景下，Webpack 会生成多个 chunk 文件，每个文件包含一部分模块的代码，然后将这些 chunk 文件合并成一个或多个 bundle 文件，以便在浏览器中加载和执行。 4. 如何使用 Webpack 进行代码分割代码分离（Code Spliting） 是 webpack 一个非常重要的特性，它主要的目的是将代码剥离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件。 webpack 常用的代码分离方式有三种： 入口起点：使用 entry 配置手动分离代码； 防止重复：使用 EntryDependencies 或者 SplitChunksPlugin 去重和分离代码： 动态导入：通过模块的内联函数用来分离代码 4.1 方式一：多入口起点这是迄今为止最简单直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患，我们将会解决这些问题。 先来看看如何从 main bundle 中分离 another module(另一个模块) 4.1.1 没有代码分离时创建一个小的 demo： 首先我们创建一个目录，初始化 npm，然后在本地安装 webpack、webpack-cli、loadsh mkdir webpack-democd webpack-demonpm init -ynpm install webpack webpack-cli lodash –save-dev复制代码 创建 src/index.js： import _ from “lodash”; console.log(_);复制代码 创建 src/another-module.js： import _ from ‘lodash’; console.log(_);复制代码 创建 webpack.config.js： const path = require(“path”); module.exports = { mode: “development”, entry: “./src/index.js”, output: { path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, },};复制代码 在 package.json 中添加命令： “scripts”: { “build”: “webpack”},复制代码 执行命令进行打包： npm run build复制代码 生成如下构建结果： 可以看到此时生成了一个 554KB 的 main.js 文件 4.1.2 有代码分离时接下来我们从 main bundle 中分离出 another module(另一个模块) 修改 webpack.config.js const path = require(“path”);module.exports = { mode: “development”, entry: ‘./src/index’, entry: { index: ‘./src/index’, another: ‘./src/another-module.js’ },output: { path: path.resolve(__dirname, “dist”), filename: “main.js”, filename: “[name].main.js”,},};复制代码 打包，生成如下构建结果： 我们发现此时已经成功打包出 another.bundle.js 和 index.bundle.js 两个文件了，但是文件的大小似乎有些问题，怎么两个都是 554KB？ 正如前面提到的，这种方式存在一些隐患： 如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。 这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。 以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 ./src/index.js 中也引入过 lodash，这样就在两个 bundle 中造成重复引用。在下一小节我们将移除重复的模块。 4.1.3 优化：移除重复的模块在通过多入口分离代码的方式中，我们可以通过配置 dependOn 这个选项来解决重复模块的问题，它的原理就是从两个文件中抽出一个共享的模块，然后再让这两个模块依赖这个共享模块。 修改 webpack.config.js 配置文件： const path = require(‘path’); module.exports = { mode: ‘development’, entry: { index: ‘./src/index.js’, another: ‘./src/another-module.js’, index: { import: ‘./src/index.js’, dependOn: ‘shared’, }, another: { import: ‘./src/another-module.js’, dependOn: ‘shared’, }, shared: [‘lodash’],},output: { filename: ‘[name].bundle.js’, path: path.resolve(__dirname, ‘dist’),},};复制代码 打包，生成如下构建结果： 可以看到 index.mian.js 和 another.mian.js 中重复引用的部分被抽离成了 shared.main.js 文件，且 index.mian.js 和 another.mian.js 文件大小也变小了。 4.2 方式二：splitChunks 模式另外一种分包的模式是 splitChunks，它底层是使用 SplitChunksPlugin 来实现的： SplitChunksPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。 因为该插件 webpack 已经默认安装和集成，所以我们并 不需要单独安装和直接使用该插件；只需要提供 SplitChunksPlugin 相关的配置信息即可 webpack 提供了 SplitChunksPlugin 默认的配置，我们也可以手动来修改它的配置： 比如默认配置中，chunks 仅仅针对于异步（async）请求，我们可以设置为 initial 或者 all ， 4.2.1 splitChunk 的配置 在 1.1.2 的基础上修改 webpack.cofig.js： const path = require(‘path’); module.exports = { mode: &apos;development&apos;, entry: { index: &apos;./src/index.js&apos;, another: &apos;./src/another-module.js&apos;, }, output: { filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;), }, optimization: { splitChunks: { chunks: ‘all’, }, },};复制代码 打包，生成如下构建结果： 使用 optimization.splitChunks 配置选项之后，现在应该可以看出，index.bundle.js 和 another.bundle.js 中已经移除了重复的依赖模块。需要注意的是，插件将 lodash 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。 除了 webpack 默认继承的 SplitChunksPlugin 插件，社区中也有提供一些对于代码分离很有帮助的 plugin 和 loader，比如： mini-css-extract-plugin: 用于将 CSS 从主应用程序中分离。 4.2.2 SplitChunks 自定义配置解析关于 optimization.splitChunks 文档上有很详细的记载，我这里讲你叫几个常用的： 1. Chunks: 默认值是 async 另一个值是 initial，表示对通过的代码进行处理 all 表示对同步和异步代码都进行处理 2. minSize ： 拆分包的大小, 至少为 `minSize； 如果一个包拆分出来达不到 minSize ,那么这个包就不会拆分； 3. maxSize： 将大于maxSize的包，拆分为不小于minSize的包； 4. cacheGroups： 用于对拆分的包就行分组，比如一个 lodash 在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打包； test 属性：匹配符合规则的包； name 属性：拆分包的 name 属性； filename 属性：拆分包的名称，可以自己使用 placeholder 属性； 修改 webpack.config.js const path = require(“path”); module.exports = { mode: “development”, entry: { index: &quot;./src/index.js&quot;, another: &quot;./src/another-module.js&quot;, }, output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), }, optimization: { splitChunks: { chunks: &quot;all&quot;, // 拆分包的最小体积 // 如果一个包拆分出来达不到 minSize，那么这个包就不会拆分（会被合并到其他包中） minSize: 100, // 将大于 maxSize 的包，拆分成不小于 minSize 的包 maxSize: 10000, // 自己对需要拆包的内容进行分组 cacheGroups: { 自定义模块的name: { test: /node_modules/, filename: &quot;[name]_vendors.js&quot;, }, }, }, },};复制代码 打包，生成如下构建结果： 4.3 方式三：动态导入(dynamic import)另外一个代码拆分的方式是动态导入时，webpack 提供了两种实现动态导入的方式： 第一种，使用 ECMAScript 中的 import() 语法来完成，也是目前推荐的方式； 第二种，使用 webpack 遗留的 require.ensure，目前已经不推荐使用； 动态 import 使用最多的一个场景是懒加载（比如路由懒加载） 4.3.1 import 方式接着从 1.1.2 小节代码的基础上修改： 修改 webpack.confg.js： const path = require(“path”); module.exports = { entry: “./src/index.js”, mode: “development”, entry: { index: &quot;./src/index.js&quot;, }, output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), },};复制代码 删除 src/another-module.js 文件 修改 src/index.js，不再使用 statically import (静态导入) lodash，而是通过 dynamic import(动态导入) 来分离出一个 chunk： const logLodash = function () { import(&quot;lodash&quot;).then(({ default: _ }) =&gt; { console.log(_); }); }; logLodash(); 复制代码之所以需要 default，是因为 webpack 4 在导入 CommonJS 模块时，将不再解析为 module.exports 的值，而是为 CommonJS 模块创建一个 artificial namespace 对象。 打包，生成如下构建结果： 由于 import() 会返回一个 promise，因此它可以和 async 函数一起使用。下面是如何通过 async 函数简化代码： const logLodash = async function () { const { default: _ } = await import(&quot;lodash&quot;); console.log(_); }; logLodash(); 复制代码4.3.2 动态导入的文件命名因为动态导入通常是一定会打包成独立的文件的，所以并不会再 cacheGroups 中进行配置； 它的命名我们通常会在 output 中，通过 chunkFilename 属性来命名： 修改 webpack.config.js const path = require(“path”); module.exports = { entry: “./src/index.js”, mode: “development”, entry: { index: &quot;./src/index.js&quot;, }, output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), chunkFilename: “chunk_[name].js””},}; 复制代码 打包构建： 如果对打包后的 [name] 不满意，还可以通过 magic comments（魔法注释）来修改： 1， 修改 src/index.js： const logLodash = async function () { const { default: _ } = await import(/*webpackChunkName: &apos;lodash&apos;*/ &quot;lodash&quot;); console.log(_); }; logLodash(); 复制代码 打包构建 5. 什么是 Tree Shaking？如何使用 Webpack 实现？什么是 Tree Shaking ？ Tree Shaking 是一个术语，在计算机中表示消除死代码（dead_code）； 最早的想法起源于 LISP，用于消除未调用的代码（纯函数无副作用，可以放心的消除，这也是为什么要求我们在进行函数式编程时，尽量使用纯函数的原因之一）； 后来 Tree Shaking 也被应用于其他的语言，比如 JavaScript、Dart； JavaScript 的 Tree Shaking： 对 JavaScript 进行 Tree Shaking 是源自打包工具 rollup； 这是因为 Tree Shaking 依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）； webpack2 正式内置支持了 ES2015 模块，和检测未使用模块的能力； 在 webpack4 正式扩展了这个能力，并且通过 package.json 的 sideEffects 属性作为标记，告知 webpack 在编译时，哪里文件可以安全的删除掉； webpack5 中，也提供了对部分 CommonJS 的 tree shaking 的支持； ✓ github.com/webpack/cha… 5.1 webpack 实现 Tree Shakingwebpack 实现 Tree Shaking 采用了两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的； sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用； usedExports 按 sideEffects 这两个东西的优化是不同的事情。 引用官方文档的话： The sideEffects and usedExports（more konwn as tree shaking）optimizations are two different things 下面我们分别来演示一下这两个属性的使用 5.1.1 usedExports 新建一个 webpack-demo。 mkdir webpack-democd webpack-demonpm init -ynpm install webpack webpack-cli lodash –save-dev复制代码 创建 src/math.js 文件： export const add = (num1, num2) =&gt; num1 + num2;export const sub = (num1, num2) =&gt; num1 - num2;复制代码 在这个问价中仅是导出了两个函数方法 创建 src/index.js 文件：、 import { add, sub } from “./math”; console.log(add(1, 2));复制代码 在 index.js 中 导入了刚刚创建的两个函数，但是只使用了 add 配置 webpack.config.js： const path = require(“path”); module.exports = { mode: “development”, devtool: false, entry: “./src/index.js”, output: { path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, }, optimization: { usedExports: true, },};复制代码 为了可以看到 usedExports 带来的效果，我们需要设置为 development 模式。因为在 production 模式下，webpack 默认的一些优化会带来很大的影响。 设置 usedExports 为 true 和 false 对比打包后的代码： 仔细观察上面两张图可以发现当设置 usedExports: true 时，sub 函数没有导出了，另外会多出一段注释：unused harmony export mul；这段注释的意义是会告知 Terser 在优化时，可以删除掉这段代码。 这个时候，我们将 minimize 设置 true： usedExports 设置为 false 时，sub 函数没有被移除掉； usedExports 设置为 true 时，sub 函数有被移除掉； 所以，usedExports 实现 Tree Shaking 是结合 Terser 来完成的。 5.1.2 sideEffects在一个纯粹的 ESM 模块世界中，很容易识别出哪些文件有副作用。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 webpack compiler 哪些代码是“纯粹部分”。 通过 package.json 的 &quot;sideEffects&quot; 属性，来实现这种方式。 { &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: false } 复制代码如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack 它可以安全地删除未用到的 export。 &quot;side effect(副作用)&quot; 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。 如果你的代码确实有一些副作用，可以改为提供一个数组： { &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [&quot;./src/some-side-effectful-file.js&quot;] } 复制代码 注意，所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 css-loader 并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除： { &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [&quot;./src/some-side-effectful-file.js&quot;, &quot;*.css&quot;] } 复制代码5.2 CSS 实现 Tree Shaking上面将的都是关于 JavaScript 的 Tree Shaking ，对于 CSS 同样有对应的 Tree Shaking 操作。 在早期的时候，我们会使用 PurifyCss 插件来完成 CSS 的 tree shaking，但是目前该库已经不再维护了（最新更新也是在 4 年前了）； 目前我们可以使用另外一个库来完成 CSS 的 Tree Shaking：PurgeCSS，也是一个帮助我们删除未使用的 CSS 的工具； 安装 PurgeCss 的 webpack 插件： npm install purgecss-webpack-plugin -D复制代码 在 webpack.config.js 中配置 PurgeCss new PurgeCSSPlugin({ paths: glob.sync(${path.resolve(__dirname, '../src')}/**/*, { nodir: true }), only: [‘bundle’, ‘vendor’]})复制代码 paths：表示要检测哪些目录下的内容需要被分析，这里我们可以使用 glob； 默认情况下，Purgecss 会将我们的 html 标签的样式移除掉，如果我们希望保留，可以添加一个 safelist 的属性； purgecss 也可以对 less、sass文件进行处理（它是对打包后的 css 进行 tree shaking 操作）； 6. Webpack 如何实现 Hot Module Replacement（HMR）Webpack 实现 热更新 Hot Module Replacement（HMR）的主要原理是通过在运行时替换被修改的模块，而不需要重新加载整个页面或应用。 具体来说，Webpack HMR 的实现流程如下： 首先，在入口文件中添加对 HMR 的支持，例如使用 module.hot.accept 方法或 webpack-dev-server 等工具提供的 HMR API。 当某个模块发生变化时，Webpack 会构建新的模块代码，并将其传递给 HMR runtime。 HMR runtime 会将新的模块代码与当前运行的模块进行比较，找出发生变化的部分，然后将其应用到当前运行的模块上。 如果当前模块依赖其他模块，HMR runtime 会检查这些依赖模块是否也发生了变化，如果有，会递归执行上述操作，直到所有相关的模块都被更新为止。 最后，HMR runtime 会通知应用程序，告诉它哪些模块已经被更新，并提供一些回调函数，让应用程序可以根据需要进行一些额外的操作。 总之，Webpack HMR 通过在运行时替换被修改的模块，使应用程序可以保持运行状态，同时也提高了开发效率和用户体验。要实现 HMR，我们需要在入口文件中添加对 HMR 的支持，并使用 webpack-dev-server 或其他工具来提供 HMR runtime 的支持。 7. 请列举几个常用的 Webpack 插件 HtmlWebpackPlugin：该插件可以根据指定的模板生成 HTML 文件，并自动将生成的 JS 和 CSS 文件引入到 HTML 中。 CleanWebpackPlugin：该插件可以在每次构建之前清空输出目录，避免旧文件对新构建结果的影响。 MiniCssExtractPlugin：该插件可以将 CSS 文件提取出来并单独打包成一个或多个文件，以便在浏览器中异步加载。 Webpack.DefinePlugin：该插件可以定义全局变量，可以用来区分开发环境和生产环境等场景。 TerserWebpackPlugin：该插件可以压缩 JavaScript 代码，减小文件大小，加快加载速度。 CopyWebpackPlugin：该插件可以将某些文件或文件夹复制到输出目录中，例如静态资源文件等。 8. webpack 的优化策略有哪些?webpack 的优化策略包括： Tree Shaking：通过静态代码分析，找出未被引用的代码并在打包时剔除掉，以减少打包后的代码体积。 **Scope Hoisting**：将模块中的所有函数作用域合并到一个函数作用域中，以减少代码体积和函数声明语句执行时间。 Code Splitting：将代码按照路由或者功能进行拆分，实现按需加载，减少首屏加载时间。 懒加载：将某些资源的加载延迟到真正需要时再进行加载，以减少首屏加载时间。 长缓存：利用浏览器缓存机制，将打包后的文件按照版本号进行区分，提高页面访问速度。 原文：https://yejiwei.com/post/126","link":"/2023/03/09/webpack%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B7%A9%E5%9B%BA/"},{"title":"macOS上值得推荐的常用软件","text":"Author: Wee Chou@E-mail: saioukbed@qq.com Note:转载请注明本文出处链接、作者 以下所推荐的 Apps &amp; 服务，都是十分挑剔的本人在使用过许多同类应用后，所筛选出来的自认为真正可以改善生活品质或工作效率的应用 pap.er Pap.er 是一款专门为 macOS 设计的精美壁纸应用，每天更新全球最新高清壁纸；适合喜欢寻找壁纸来改变心情的你。 为什么推荐? 每天更新来自全球的高清(4k,5k)壁纸。 便捷预览壁纸功能：通过缩略图可预览壁纸，能够快速浏览众多壁纸。 强大的即用即设壁纸功能：看到喜欢的壁纸，一键就能设置成为当前桌面壁纸。 壁纸管理便捷：下载过的壁纸，我们贴心的存放到了下载目录，通过应用内直接打开就可以管理。 无广告！无广告！无广告！ =====(づ′▽`)づ ===== IINA IINA 基于 mpv，为最新 Mac 系统而生，支持 Touch Bar、兼容 MPV 脚本、几乎支持所有格式、网络播放，是一款拥有优雅外观的视频播放器。 为什么推荐? 更快和更稳定的解码效果 丰富的设置项 0.25x~16x变速 支持dark mode 免费 开源 无广告 =====(づ′▽`)づ===== Alfred Alfred 这是一款被称之为Mac效率神器的App，有了Alfred 你甚至无需鼠标就可以实现各种操作，包括出发各种文件、网络操作，其UI界面使用方便，而且不是通过命令来实现，是开发者们和键盘刘童鞋们的神器，比之此前类似的软件——Pack和Power来说完全是秒杀的节奏。 应用介绍 这是最基本的了，option+空格激活以后，输入关键字就开始搜索，默认会匹配已经安装的应用软件，我还设置了搜索Safari书签。如果无法匹配，那么会出现搜索google之类的选项，直接触发打开浏览器到搜索引擎搜索。 和Spotlight直接搜索各种类型不同，Alfred要多敲一个空格或者单引号来指示它搜索文件名。实际使用中，我觉得这样更方便和快捷，alfred几乎是秒出结果，而spotlight在迅速反馈结果的同时，有个逐步增加的过程。就对文件的实际搜索效果来说，alfred对文件名的模糊搜索是OK的，但不如Devonthink连文件内容一概通杀的彪悍。当然，DT的彪悍也是在你索引以后的结果，各有专长吧。Spotlight感觉居中，支持文件内容搜索，但仍然不如DT彻底。顺便说一句，DT这几天在促销，可以看这里。 估计键盘流里很多是所谓geek吧，所以alfred支持直接一个“&gt;”后，打开终端执行命令行。 alfred还贴心的支持了和1password的整合。 强力功能需付费!","link":"/2020/05/12/macOSapps/"},{"title":"事件模型","text":"原始事件模型（DOM0级） 这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件： 在html代码中直接指定属性值： 1&lt;button id=\"demo\" type=\"button\" onclick=\"doSomeTing()\" /&gt; 在js代码中为: 1document.getElementsById(\"demo\").onclick = doSomeTing(); 优点：所有浏览器都兼容 缺点：1）逻辑与显示没有分离；2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。 因为这些缺点，虽然原始事件类型兼容所有浏览器，但仍不推荐使用。 DOM2事件模型 此模型是W3C制定的标准模型，现代浏览器（IE6~8除外）都已经遵循这个规范。W3C制定的事件模型中，一次事件的发生包含三个过程： 1.事件捕获阶段2.事件目标阶段3.事件冒泡阶段 如下图所示: &nbsp;IE 5.5: div -&gt; body -&gt; document &nbsp;IE 6.0: div -&gt; body -&gt; html -&gt; document &nbsp;Mozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window &nbsp;&nbsp;&nbsp;&nbsp;所有的事件类型都会经历事件捕获但是只有部分事件会经历事件冒泡阶段,例如submit事件就不会被冒泡。 事件的传播是可以阻止的： 在W3c中，使用stopPropagation（）方法 在IE下设置eve.cancelBubble = true；在捕获的过程中stopPropagation（）；后，后面的冒泡过程就不会发生了。 标准的事件监听器该如何绑定： &nbsp;&nbsp;&nbsp;&nbsp;addEventListener(“eventType”,”handler”,”true|false”);其中eventType指事件类型，注意不要加’on’前缀，与IE下不同。第二个参数是处理函数，第三个即用来指定是否在捕获阶段进行处理，一般设为false来与IE保持一致(默认设置)，除非你有特殊的逻辑需求。监听器的解除也类似：removeEventListner(“eventType”,”handler”,”true!false”); 事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。 摘自: [https://www.cnblogs.com/leftJS/p/10948138.html]","link":"/2020/08/11/%E4%BA%8B%E4%BB%B6/"},{"title":"函数的作用域、作用域链以及return关键字","text":"作用域全局作用域：在函数外部使用var关键字定义的变量局部作用域：在函数内部使用var关键字定义的变量 特点： 局部变量无法直接影响全局变量 在局部作用域中可以使用全局作用域的变量 作用域链函数内部变量在进行查询时，遵循的规则： 首先从函数自身所在的作用域进行查找 若没有，则向父级或者是先辈作用域进行查找 若没有，最终的值就是undefined 局部变量影响全局变量的方法 在函数内部不使用var关键字定义变量 使用return关键字将局部变量的值返回到函数外部，必须使用对应的变量进行接收 return关键字作用 将函数内部变量的值返回到函数外部 return关键字后面的程序不再执行 转载自: [https://www.cnblogs.com/sherryStudy/p/function_field.html]","link":"/2020/08/10/%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%BB%A5%E5%8F%8Areturn%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"前端杂谈","text":"Recorder: Wee Chou z-index仅同级Element有效,父子关系只需修改子元素 npm init –yes 生成package.js 且全部选yes选项 **Element.closest()** 方法用来获取：匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。 很重要!!!!在事件委托上很常用 getBoundingClientRect() 获取坐标， 当元素没有left top值时，通过获取坐标来获取位置参数。 很重要！！！！ element.insertAdjacentHTML(position, text) 回流必将引起重绘, 而重绘不一定会引起回流(回流: 改变元素的布局或尺寸…;重绘: 仅改变元素的外观,不会影响布局) 基线总是与行内高度最高的元素一致的 边缘折叠,两个边距中较小的边距被较大的边距所取代 负页边距确实会对垂直格式产生影响，并影响页边距的折叠方式 vertical-align 改变基线的位置 display: grid; 网格布局 很好用 CSS中脱离文档流，bai也就是将元素从普通的布局排版中拿走，其他盒zhi子在定位的时候，会当做脱dao离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。 这个用于视口的meta标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。 多列布局: column-width: 12em; column-width: 4(固定列数,宽度可变) 善于利用calc设定尺寸 -&gt; 例如 calc(50% - 10px) 不能从dispaly:none 开始过渡, 因为还没开始”绘制” 递归 {需要有个结尾} like return 0; 使用原型是为了共享属性和方法 所有引用类型都继承了Object","link":"/2020/08/06/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%B0%88/"},{"title":"初探Nuxtjs","text":"在我大致阅读完Vue的官方文档后，觉得不够过瘾，正好文档中有提到Nuxt，出于好奇，我打开了Nuxt的官方文档。 什么是NuxtJS简而言之，Nuxt是运行在node环境的SSR（服务端渲染）框架，且基于Vue。Vue负责开发多页应用，Nuxt在此之上再做拓展，可以直接用命令生成完整的html页面，在服务器端完成渲染。 什么是SSR在认识SSR之前，首先对CSR与SSR之间做个对比。 首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接HTML字符串（模板），通过一系列的数据处理之后，把整理好的HTML返回给客户端,浏览器相当于打开了一个页面。这种比如我们经常听说过的jsp,PHP,aspx也就是传统的MVC的开发。 SPA应用，到了Vue、React，单页面应用优秀的用户体验，逐渐成为了主流，页面整体式javaScript渲染出来的，称之为客户端渲染（CSR）。SPA渲染过程。由客户端访问URL发送请求到服务端，返回HTML结构（但是SPA的返回的HTML结构是非常的小的，只有一个基本的结构，如第一段代码所示）。客户端接收到返回结果之后，在客户端开始渲染HTML，渲染时执行对应javaScript，最后渲染template，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回json格式数据。客户端接收数据，然后完成最终渲染。 SPA虽然给服务器减轻了压力，但是也是有缺点的： 首屏渲染时间比较长：必须等待JavaScript加载完毕，并且执行完毕，才能渲染出首屏。SEO不友好：爬虫只能拿到一个div元素，认为页面是空的，不利于SEO。为了解决如上两个问题，出现了SSR解决方案，后端渲染出首屏的DOM结构返回，前端拿到内容带上首屏，后续的页面操作，再用单页面路由和渲染，称之为服务端渲染(SSR)。 SSR渲染流程是这样的，客户端发送URL请求到服务端，服务端读取对应的url的模板信息，在服务端做出html和数据的渲染，渲染完成之后返回html结构，客户端这时拿到的之后首屏页面的html结构。所以用户在浏览首屏的时候速度会很快，因为客户端不需要再次发送ajax请求。并不是做了SSR我们的页面就不属于SPA应用了，它仍然是一个独立的spa应用。 SSR是处于CSR与SPA应用之间的一个折中的方案，在渲染首屏的时候在服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在服务端接收到请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给客户端去渲染其他路由的页面。 via掘金:LuSir63227 Nuxt.js的特点（优点）： 基于Vue 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 EcmaScript6和EcmaScript7的语法支持 打包和压缩JavaScript和CSS HTML头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式预编译器SASS、LESS等等 支持HTTP/2推送 Nuxt环境搭建安装依赖开始之前需要先安装node，且版本大于8.9.0，下面是链接 https://nodejs.org/en/download/（建议安装LTS的最新版本） 从零构建创建项目文件夹，将工作目录切换到项目文件夹 12mkdir &lt;project-name&gt;cd &lt;project-name&gt; 然后创建依赖管理文件 1touch package.json 打开package.json，编辑基本信息 123456789{ \"name\": \"my-app\", \"scripts\": { \"dev\": \"nuxt\", \"build\": \"nuxt build\", \"generate\": \"nuxt generate\", \"start\": \"nuxt start\" }} 安装Nuxt一旦package.json被创建了，我们就可以通过包管理工具安装依赖，这里我们使用npm 1npm install nuxt 随后nuxt会被添加到package.json中，并自动生成node_modules文件夹 创建第一个页面在项目工作目录下： mkdir pagestouch pages/index.vue 该组件将作为默认页面的内容显示接下来为组件加入内容 123&lt;template&gt; &lt;h1&gt;Hello world!&lt;/h1&gt;&lt;template&gt; 启动服务在终端输入npm run dev命令，就会在本地http://localhost:3000 路由与单纯使用vue不同，nuxt对vue的路由进行了封装，依据pages的目录结构，nuxt会自动生成vue-router模块的路由配置 假设 pages的目录如下 └─pages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─index.vue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─index.vue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─one.vue 则Nuxt.js自动生成的路由配置如下： 12345678910111213141516171819router: { routes: [ { name: 'index', path: '/', component: 'pages/index.vue' }, { name: 'user', path: '/user', component: 'pages/user/index.vue' }, { name: 'user-one', path: '/user/one', component: 'pages/user/one.vue' } ]}","link":"/2020/08/27/%E5%88%9D%E6%8E%A2Nuxtjs/"},{"title":"使用react-saga","text":"redux-saga是一个Redux中间件，我在日常的开发中，将它作为发送异步请求的组件。 我认为它的根本作用是降低耦合度，因为在生命周期函数中我们同样可以发送并接受异步请求/结果 用户发出Action，Reducer计算出新的state，view重新渲染。像这样立即算出state的是同步的操作。 redux中的数据流大致是： UI——&gt;action(plain)——&gt;reducer——&gt;state——&gt;UI\\ redux遵循函数式编程的规则，上述的数据流中，action是一个原始js对象(plain object)且reducer是一个纯函数，对于同步且没有副作用的操作，上述的数据流起到可以管理数据，从而控制视图层更新的目的。 但是如果存在副作用，比如ajax异步请求等等，那么应该怎么做？\\ 如果存在副作用函数，那么我们需要首先处理副作用函数，然后生成原始的js对象。如何处理副作用操作，在redux中选择在发出action，到reducer处理函数之间使用中间件处理副作用\\。 redux增加中间件处理副作用后的数据流大致如下： UI——&gt;action(side function)——&gt;middleware——&gt;action(plain)——&gt;reducer——&gt;state——&gt;UI\\ 在有副作用的action和原始的action之间增加中间件处理，中间件的作用就是：转换异步操作，生成原始的action，这样，reducer函数就能处理相应的action，从而改变state，更新UI。\\ redux-saga的基本使用 配置中间件 src/store/index.js 123456789101112131415import { createStore, applyMiddleware } from 'redux'import reducer from './reducer'import createSagaMiddleware from 'redux-saga'import rootSaga from './saga'const sagaMiddleware = createSagaMiddleware() // 创建中间件export const store = createStore( reducer, // 挂载 applyMiddleware(sagaMiddleware))// 执行sagaMiddleware.run(rootSaga) saga.js src/store/saga.js 123456789101112131415161718192021222324252627282930313233343536import { call, put, takeEvery } from 'redux-saga/effects'// 用于存放action type 常量import { GET_HOME_LIST } from '../pages/home/store/contants'// function* 生成器函数，他将返回一个Generator对象function* getHomeList(action) { // fetch是ES6提供的原生方法 const p = () =&gt; fetch([your url],{ method: 'GET' }) // 比axios多了这一步 .then(res=&gt; res.json()) .then(res=&gt;{ if (res.success) { return res.data }else { console.log('网络请求失败') } }) // 用call接受p异步函数返回的结果 const res = yield call(p) // 触发success action并带上异步结果 yield put({ type: GET_HOME_LIST_SUCCESS, payload: res })}function* rootSage() { // getHomeList指上面的getHomeList生成器函数 yield takeEvery(GET_HOME_LIST, getHomeList)}export default rootSage 3.reducer.js src/store/reducer.js 12345678910export default (state = defaultState, action) =&gt; { switch (action.type) { case GET_HOME_LIST_SUCCESS: // do something // 将接收到的action.payload进行一系列操作，并拼接到state中 return state default: return state }} 最初的action由UI组件发起 12345678910111213141516171819202122import { connect } from 'react-redux'import { getMoreHomeList } from '../store/actionCreator'//省略JSX部分...// 以下使用react-redux映射（同步）state、dispatch，使结构更清晰，降低耦合度// 将redux的state映射到this.props中const mapState = state =&gt; ({ articleList: state.getIn(['home', 'articleList']), loading: state.getIn(['home', 'loading'])})// 将redux的store.dispatch映射到this.props中const mapDispatch = dipatch =&gt; ({ handleLoadMore(e) { e.preventDefault() // 通过dispatch发送action dipatch(getMoreHomeList()) }})export default connect(mapState, mapDispatch)(List); 通过上述章节，我们可以概括出redux-saga做为redux中间件的全部优点： 统一action的形式，在redux-saga中，从UI中dispatch的action为原始对象 集中处理异步等存在副作用的逻辑 通过转化effects函数，可以方便进行单元测试 完善和严谨的流程控制，可以较为清晰的控制复杂的逻辑。 参考:[https://www.jianshu.com/p/05b73d826425]","link":"/2020/09/15/%E4%BD%BF%E7%94%A8react-saga/"},{"title":"原型模式","text":"什么是原型?我们创建的每个函数都有一个 prototype 属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。若按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的对象实例的原型对象。 原型是 Javascript 中的继承的基础，JavaScript 的继承就是基于原型的继承。 使用原型的好处？使用原型的好处是可以让所有对象实例共享属性和方法，而不用多次构建相同的属性或方法，占用多余的内存。 举一个最简单的例子： 123456789function Person() {}Person.prototype.name = \"wee\"; // 在Person原型中设定name属性var person1 = new Person();var person2 = new Person();console.log(person1.name);console.log(person2.name); // 两个同类但不同的实例都能从其原型中访问到name 创建实例对象最好的办法，是结合构造函数模式和原型模式。使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 1234567891011121314function SuperType(name) { this.name = name; this.colors = ['red','purple'];}SuperType.prototype.sayName = function() { console.log(this.name)}function SubType(name, age) { SuperType.call(this, name); // 继承属性,目的是为了让this指向SubType实例对象,使SuperType中的this this.age = age;}subType.prototype = new SuperType() // 继承方法var sub = new SubType('wee','')","link":"/2020/08/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"基于Vue-cli2.x的项目构建流程","text":"记录使用vue-cli脚手架项目构建流程 &amp;&amp; Debug过程 Author: wee chou 环境参数nodejs &gt;=6.2.2npm &gt;= 3.9vue &gt;= 2.5.2IDE vscodeGitgithub平台账户 安装依赖 vscode 宇宙第一IDE 好用的（前端）插件： Chinese（友好的简体中文界面）ESLint（严格的代码审查）Live Server（在本地搭建临时的微服务器）Vetur（格式化代码） node.js 建议安装较为稳定的 LTS 版本 根据提示安装完成后,通过 node -v 命令校验是否安装成功 Vue CDN:https://cdn.jsdelivr.net/npm/vue/dist/vue.jshttps://unpkg.com/browse/vue@2.6.11/dist/vue.js 脚手架的依赖项包含了vue库，因此可以一步到位，不需要再次引用 Vue-cli 通过npm包管理工具全局安装vue-cli（npm是node的包管理工具，不用再次安装）npm install --global vue-cli 项目构建执行命令 vue init webpack Travel 经过一系列设置后，项目的整体架构就搭建好了 配置方法 别名alias 在使用vue-cli架构时，想要引入外部文件，可以使用语法糖‘@’简写路径，而‘@’代表src文件夹。想要添加自定义路径，可以在build/webpack.base.conf.js文件中进行设置 1234567resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), }}, 常见问题 less和less-loader版本号不一致 开发中想要用less添加样式，于是在终端安装依赖： &nbsp;&nbsp;npm install less less-loader --save 提示安装成功，在使用过程中却报了许多错误信息，通过查阅资料得知是因为less和less-loader版本号不一致。解决办法也很简单，卸载之前的less-loader，用添加版本号的方式重新安装： &nbsp;&nbsp;npm install less-loader@3 --save","link":"/2020/08/21/%E5%9F%BA%E4%BA%8EVue-cli2-x%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"title":"常见排序算法","text":"&nbsp;&nbsp;&nbsp;&nbsp;算法在平时的前端业务开发中其实不太能用得到，但了解其原理，可以提高我们的思维逻辑能力，也能够作为代码性能优化的知识储备。 排序冒泡排序 冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作会重复地进行，直到没有再需要交换的元素为止，此时排序完成。 以下是冒泡排序的基本实现步骤： 比较相邻的元素。如果第一个比第二个大，就交换它们的位置。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这样在最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上述步骤，直到没有任何一对数字需要比较为止。冒泡排序的时间复杂度为 O(n²)，其中 n 是要排序的元素个数。虽然冒泡排序是一个简单的算法，但它的效率较低，不适合处理大规模的数据。 用JS实现 1234567891011121314function bubbleSort(arr) { const len = arr.length; for (let i = 0; i &lt; len - 1; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr;}const arr = [5, 3, 8, 4, 2];console.log(bubbleSort(arr)); // 输出 [2, 3, 4, 5, 8] 快速排序 快速排序是一种高效的排序算法，它的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列。 以下是快速排序的基本实现步骤： 从数列中挑出一个基准值（通常选择第一个数）。 将所有比基准值小的元素移到基准值前面，将所有比基准值大的元素移到基准值后面（相同的数可以放到任一一边）。 递归地对小于基准值的子数列和大于基准值的子数列进行快速排序。 1234567891011121314151617181920function quickSort(arr) { if (arr.length &lt;= 1) { return arr; } const pivotIndex = Math.floor(arr.length / 2); // 选取基准值的下标 const pivot = arr.splice(pivotIndex, 1)[0]; // 选取基准值并从原数组中删除 const left = []; const right = []; for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return [...quickSort(left), pivot, ...quickSort(right)]; // 递归排序左右两个子数组并合并结果}const arr = [5, 3, 8, 4, 2];console.log(quickSort(arr)); // 输出 [2, 3, 4, 5, 8]","link":"/2020/12/29/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"快速构建React单页应用","text":"习惯了Vue的开发模式，想尝试一下更加低粒度的React框架。 开发环境 node LTS latest VScode Create React App对于React初学者来说（比如此刻的我），快速构建应用无非省去了很多准备工作，从而提高开发效率。利用Create React App可以快速构建一个React单页应用，只需在终端执行下列命令。 &nbsp;&nbsp;npx create-react-app my-app &nbsp;&nbsp;cd my-app &nbsp;&nbsp;npm start 注意第一行的 npx 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。","link":"/2020/09/02/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"},{"title":"基于 vite4 + vue3 + TS 从零搭建一个组件库","text":"基于 vite + vue3 + ts 的组件库，意于巩固相关知识点，完善后可供开发者使用 vite支持ts： https://blog.csdn.net/u012961419/article/details/110520129 官网搭建vite官方文档：https://vitejs.dev/ 创建项目使用脚手架构建项目并自定义配置（这里使用yarn，也可以使用你喜欢的其他包管理工具） 1yarn create vite 或者跳过自定义配置阶段，直接构建项目 12# yarnyarn create vite my-vue-app --template vue 安装依赖123yarn# oryarn install 启动项目1yarn run dev 服务启动之后，访问对应的url地址就能看到效果啦 （初始页面这里建议我们搭配Volar插件进行开发） 环境配置补充类型声明在初始化项目后，可以看到项目成功跑起来了，但回到代码当中，却发现 因为在ts项目当中，.ts文件是无法识别.vue文件的，所以我们需要创建.d.ts文件并在其中添加报错相应的声明（.d.ts文件在项目中放置的位置需要与tsconfig.json中include属性声明.d.ts的文件路径同步，否则依然会报错） 像这样声明之后，对应的红色波浪线报错就会消失了 对页面进行初步搭建顶部菜单栏这里我们需要安装vue-router，实现路由切换 1yarn add vue-router@4 创建顶部导航栏，首页以及文档页顶部导航栏 1234567&lt;!-- 顶部导航栏 --&gt;&lt;template&gt; &lt;div id=&quot;navBar&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/doc&quot;&gt;文档&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; doc文档页 1234&lt;!-- 文档页 --&gt;&lt;template&gt; &lt;div&gt;doc&lt;/div&gt;&lt;/template&gt; home首页 1234&lt;!-- 首页 --&gt;&lt;template&gt; &lt;div&gt;home&lt;/div&gt;&lt;/template&gt; 路由配置单独维护路由配置，降低耦合度 123456789101112131415import { createRouter, createWebHashHistory } from 'vue-router'import Home from '@/components/home.vue'import Doc from '@/components/doc.vue'const routes = [ { path: '/', component: Home }, { path: '/doc', component: Doc }]const router = createRouter({ history: createWebHashHistory(), routes})export default router main.ts 12345678910import { createApp } from 'vue'import App from './App.vue'import Router from './router'import './assets/normalize.css'const app = createApp(App)// 挂载路由app.use(Router)app.mount('#app') 封装按钮组件创建文档页介绍组件安装vite-plugin-markdown有了它你可以在vite项目中导入并使用Markdown文件 1yarn add vite-plugin-markdown --dev 封装Markdown组件123456789101112&lt;template&gt; &lt;article class=&quot;markdown&quot; v-html=&quot;content&quot;&gt;&lt;/article&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;const props = defineProps({ content: { type: String, default: '' }})&lt;/script&gt; 新增类型声明新增 *.md类型声明，否则ts文件不认识md文件 （这里对声明文件做个解释补充：由于ts是强类型语言，在编译过程中会检查是否对各个变量声明类型，如果遇到没有声明类型的变量会有【缺少类型】的报错，所以我们需要在.d.ts声明文件中添加未被记录的类型声明） 1234declare module '*.md' { const html: String export { html }} 新增文档页子路由123456789101112131415161718192021// index.tsimport { createRouter, createWebHashHistory } from 'vue-router'import Home from '@/views/home/index.vue'import Doc from '@/views/doc/index.vue'import docRouters from './doc-routers'const routes = [ { path: '/', component: Home }, { path: '/doc', component: Doc, children: docRouters }]const router = createRouter({ history: createWebHashHistory(), routes})export default router 123456789101112131415161718192021// doc-routers.tsimport { h } from 'vue'import Button from '@/views/doc/button/index.vue'import Markdown from '@/components/Markdown.vue'const md = (html: any) =&gt; h(Markdown, { content: html })import { html as Intro } from '../markdown/intro.md'const IntroDoc = md(Intro)const routes = [ { path: 'intro', component: IntroDoc }, { path: 'button', component: Button }]export default routes 代码块展示功能自定义插件vue-custom-blocks-plugin12345678910111213141516171819202122232425262728// TODO注释import fs from \"fs\";import { baseParse } from \"@vue/compiler-core\";const vitePluginVue = { name: \"preview\", transform(code, id) { // 每个被插件跟踪到的文件都会执行一遍 if ( !/\\/src\\/views\\/doc\\/.*\\.preview\\.vue/.test(id) || !/vue&amp;type=preview/.test(id) ) { return; } let path = `.${id.match(/\\/src\\/views\\/doc\\/.*\\.preview\\.vue/)[0]}`; const file = fs.readFileSync(path).toString(); // 用于读取preview标签中的内容，作为title const parsed = baseParse(file).children.find((n) =&gt; n.tag === \"preview\"); const title = parsed.children[0].content; const main = file.split(parsed.loc.source).join(\"\").trim(); return `export default function (Component) { Component.__sourceCode = ${JSON.stringify(main)} Component.__sourceCodeTitle = ${JSON.stringify(title)} }`.trim(); },};export default vitePluginVue; 将插件挂载到vite.config.ts123456import vitePluginVue from './plugins/vue-custom-blocks-plugin'export default defineConfig({ plugins: [vue(), mdPlugin({ mode: [Mode.HTML] }), vitePluginVue], ...}) 效果展示 发布到npm安装rollup 这里用其他打包工具也行，因为只是上传组件库所以采用rollup，比较轻量 12# 我这里选择全局安装，也可以局部安装npm install rollup -g 配置rollup.config.js安装相关依赖 rollup-plugin-esbuild：将ts编译成ES6 @vitejs/plugin-vue rollup-plugin-scss：转译scss文件 rollup-plugin-terser：代码压缩插件，转译es6+语法 123456789101112131415161718192021222324252627282930import esbuild from 'rollup-plugin-esbuild'import vue from '@vitejs/plugin-vue'import scss from 'rollup-plugin-scss'import DartScss from 'sass'import { terser } from 'rollup-plugin-terser'export default { input: 'src/lib/index.ts', // 入口文件地址 output: { globals: { vue: 'Vue' // 指明global.Vue即是外部依赖vue }, name: 'wee-ui', file: 'dist/lib/wee-ui.js', format: 'umd', plugins: [terser()] }, plugins: [ scss({ include: /.scss$/, fileName: 'wee-ui.css' }), vue({ include: /.vue$/ }), esbuild({ include: /.[jt]s$/, minify: process.env.NODE_ENV === 'production', target: 'es2015' }) ], external: ['vue']} 执行打包命令1rollup -c 打包结果 发布注册一个npm账号官网注册即可：https://www.npmjs.com/ 登录npm在登录之前，需要保证当前的npm源是官方源，否则无法成功登录 12npm config get registrynpm config set registry registry.npmjs.org 在项目终端执行 1npm login 之后会提示你输入用户名、密码、邮箱，还会向邮箱发送一个验证码，用于最后的身份验证，登录成功后会有提示 最终发布最后在发布之前，需要确认包的相关描述内容 name：npm包名 private：如果我们发布的是public包，需要将该属性改成false，不然无法成功发布 version：版本名（每次发布需要保证当前版本不同于线上的版本，否则会冲突） description：项目描述 files：要发布的内容 12345678910{ \"name\": \"kuma-ui\", \"private\": false, \"version\": \"0.0.1\", \"description\": \"kuma UI 组件库\", \"files\": [ \"dist/lib/*\" ], ...} 执行发布命令  1npm publish 发布成功后，我们就能在其他项目中使用我们自己的组件库啦，完善后还可以供其他开发者使用","link":"/2023/02/13/%E5%9F%BA%E4%BA%8E-vite4-vue3-TS-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"title":"理解async&#x2F;await","text":"async/await是ES7中新增的语法糖，可以使JavaScript的异步操作（IO操作，对资源的操作，读文件，发送http请求，操作数据库）开发更加简洁 在理解asycn/await是什么之前，我们需要理解什么是Promise例如使用jquery中的Ajax，想要获取从服务端传来的返回值，我们往往会这么做 12345678910111213$.ajax({ url: 'json.php', type: 'get', // 设置的是请求参数 data: { id: 1, name: '张三' }, // 用于设置响应体的类型 注意 跟 data 参数没关系 dataType: 'json', success: function (res) { // 一旦设置的 dataType 选项，就不再关心 服务端 响应的 Content-Type 了 // 客户端会主观认为服务端返回的就是 JSON 格式的字符串 console.log(res) }}) 其中success对应的函数就是回调函数，我们可以用回调函数获取异步操作的结果 123456789101112var b = 0function foo(callback) { setTimeout(() =&gt; { b += 1 callback(b) }, 1000);}foo(res=&gt; { console.log(res)})// 1秒后打印 1 这么一看似乎用回调函数就能完美解决问题。但如果我们想要每秒给b加1，并持续3秒该怎么做呢？这时为了维持上下文，我们不得不嵌套回调函数 1234567891011121314151617var b = 0function foo(callback) { setTimeout(() =&gt; { b += 1 callback(b) }, 1000);}foo(() =&gt; { foo(() =&gt; { foo(res =&gt; { console.log(res) }) })})// 3秒后输出3 我们可以看到，照这个趋势下去，如果要获取10秒后的结果，代码会变得非常糟糕。 在ES6中，promise的出现拯救了这样的“回调地狱”。 promise提供了几个基本的api Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 如何使用把上面的例子改成promise 1234567891011121314151617function foo(b = 0) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { b += 1 resolve(b) }, 1000); })}foo().then(res=&gt;{ return foo(res)}).then(res=&gt;{ return foo(res)}).then(res=&gt; { console.log(res)})// 3秒后输出3 虽然代码量没有减少，但代码结构明显变得更加美观，逻辑也更加清晰，更重要的是promise非常灵活，只需要用promise包裹普通函数，若成功则用resolve接受结果，若失败则用reject接受失败信息，再创建promise实例对象，调用then方法使用resolve获取到的参数，调用catch方法使用reject获取到的参数。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 而async/await其实就是配合promise的语法糖12345678910111213141516async function foo() { const b = await after1s() // 相当于 const b = after1s().then(res=&gt;res) // 捕获异常 const b = after1s().catch(error=&gt;error) console.log(b)}function after1s() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(200) }, 1000); })}foo() // 1秒后输出200 用await修饰的对象，若是promise对象，则会默认接收resolve传递过来的resolve值，也就是默认执行了then方法。 （函数内部用了await，函数就必须用async修饰，不然会报错） 用async修饰的函数，其内部运行的任何函数都会被包装成promise对象。 await会阻塞线程（异步的调用变成同步的调用），以axios举例 12 参考：https://www.jianshu.com/p/063f7e490e9a","link":"/2020/09/17/%E7%90%86%E8%A7%A3async-await/"},{"title":"理解虚拟DOM","text":"虚拟DOM并不是什么神奇的东西，它只是用来描述真实DOM的Javascript对象而已。 &nbsp;&nbsp;&nbsp;&nbsp;在传统的前端开发中，我们会大量使用DOM提供的API，直接对DOM进行增删改查一系列操作，然而每进行一次DOM操作，都会使页面重新渲染，相对来讲这是很消耗性能的。因此在前端优化中有一条原则：尽量减少DOM操作。 &nbsp;&nbsp;&nbsp;&nbsp;而虚拟DOM可以作为真实DOM的抽象，有其同等的作用，且更高效。它是一个独立的技术，只不过React使用了这项技术来提高自身性能。 &nbsp;&nbsp;&nbsp;&nbsp;在React的JSX中，每一个标签其实都可以用js来描述，例如以下DOM结构： 123&lt;div className='foo'&gt; &lt;h1&gt;Hello React&lt;/h1&gt;&lt;/div&gt; 可以用这样的javascript对象来描述： 123456789101112{ type: 'div', props: { className: 'foo', children: { type: 'h1', props: { children: 'Hello React' } } }} &nbsp;&nbsp;&nbsp;&nbsp;有了虚拟DOM这一层，当我们需要操作DOM时，就可以操作虚拟DOM，而不操作真实DOM，虚拟DOM是普通的JavaScript对象，访问JavaScript对象当然比访问真实DOM要快得多。到这里，大家可以发现，虚拟DOM并不是什么神奇的东西，它只是用来描述真实DOM的JavaScript对象而已。 \b 参考： 《React 进阶之路》","link":"/2022/10/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM/"},{"title":"用hooks实现Redux","text":"什么是Hook以下是官方解释： Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 在传统的React开发中，我们可以使用Redux提供的组件去监听全局状态，通常需要四个步骤： 用redux中的createStore方法创建store实例，并传入reducer函数（传入state、action，导出state） 由组件调用store.dispatch(action = {type:xxx,value:xxx}) 在reducer中接收action，并根据action.type执行相应操作，最终返回state store更新state后，需要组件在合适位置（通常在constructor中）发布订阅，更新视图:12345678910class A extends Component { constructor() { super() ... store.subscribe(this.updateView) } updateView() { this.setState(store.getState()) }} 那么如何用hooks实现Redux的功能呢 用hooks实现的过程中，也可以看到很多Redux的影子。我将用一个简单的例子展示如何运用hooks实现Redux，该demo划分为四部分： DemoProvider（关键，提供全局服务） Demo（父组件） DemoButton（子组件1） DemoContent（子组件2） DemoProvider.js 1234567891011121314151617181920212223242526272829import React, { createContext, useReducer } from 'react';// React.createContext 提供全局上下文export const ColorContext = createContext({})// 创建动态变量用于设置action.typeexport const UPDATA_COLOR = 'UPDATE_COLOR'// 和Rudex中一样，作为一个独立的模块处理state// 根据dispatch传来的action，执行相应的操作，返回stateconst reducer = (state, action) =&gt; { switch(action.type){ case UPDATA_COLOR: return action.color default: return state }}export const Color = props =&gt; { const [color, dispatch] = useReducer(reducer, 'blue') return ( // Provider组件，用于数据共享 &lt;ColorContext.Provider value={{color, dispatch}}&gt; {/* 表示被包裹的子组件 */} {props.children} &lt;/ColorContext.Provider&gt; )} DemoButton.js 12345678910111213141516import React, { useContext } from 'react';import { ColorContext, UPDATA_COLOR } from './DemoProvider'function Button() { // 从全局上下文中获取dispatch方法 const {dispatch} = useContext(ColorContext) return ( &lt;div&gt; {/* 和Redux中一样，触发dispatch */} &lt;button onClick={()=&gt; {dispatch({type: UPDATA_COLOR, color: 'blue'})}}&gt;be blue&lt;/button&gt; &lt;button onClick={()=&gt; {dispatch({type: UPDATA_COLOR, color: 'red'})}}&gt;be red&lt;/button&gt; &lt;/div&gt; )}export default Button DemoContent.js 1234567891011121314import React, {useContext} from 'react';import {ColorContext} from './DemoProvider'function Content() { // 监听全局上下文的变化（reducer根据action改变state，在此做出响应） let {color} = useContext(ColorContext) return ( &lt;div&gt; &lt;h1 style={{color: color}}&gt;content&lt;/h1&gt; &lt;/div&gt; )}export default Content Demo.js 123456789101112131415161718192021import React from 'react'import Button from './DemoButton'import Content from './DemoContent'// 导入Providerimport {Color} from './DemoProvider'function Demo() { return ( &lt;div&gt; &lt;h1&gt;DEMO&lt;/h1&gt; &lt;hr /&gt; {/* 使用组件 */} &lt;Color&gt; &lt;Content /&gt; &lt;Button /&gt; &lt;/Color&gt; &lt;/div&gt; )}export default Demo 可以看到，无论用hooks还是Redux，目的都是为了创建一个全局状态管理容器，它们的数据流也是一样的：","link":"/2020/09/07/%E7%94%A8hooks%E5%AE%9E%E7%8E%B0react-redux/"},{"title":"节流防抖","text":"前端开发中的防抖（Debouncing）和节流（Throttling）是优化 JavaScript 函数性能的两种常见方式。它们可以帮助控制函数被调用的频率，避免频繁触发一些高开销的操作，从而提高前端页面的性能和用户体验。 防抖防抖（Debouncing）的基本思想是，当事件被触发时，我们不立即执行该事件处理函数，而是等待一定时间后，再去执行该事件处理函数。如果在等待时间内再次触发了该事件，那么就重新计时。简单来说，防抖的作用是防止短时间内大量触发同一事件导致频繁更新DOM，而是将事件合并成一次处理。 具体实现 123456789101112131415// 防抖（立即执行版本）function debounce(fn, wait) { let timer = null return function () { let args = arguments let now = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; { timer = null }, wait) if (now) { fn.apply(this, args) } }} 节流节流（Throttling）的基本思想是，当事件被触发时，我们先判断当前是否有等待执行的延时函数。如果有，就不执行该事件处理函数，如果没有，就设置一个延时函数，在延时时间之后执行该事件处理函数。如果在等待时间内再次触发了该事件，那么就不做任何处理。简单来说，节流的作用是减少事件处理函数的触发次数，优化性能。 具体实现 1234567891011121314// 节流（定时器版本）function throttle(fn, wait) { let timer = null return function () { let context = this let args = arguments if (!timer) { timer = setTimeout(() =&gt; { timer = null fn.apply(context, args) }, wait) } }} 除了手动造轮子，实际开发中我们也可以使用 lodash 库提供的防抖和节流函数来实现。首先需要安装 lodash 库，然后在 Vue 组件中使用 import 引入该库，然后通过 Vue.mixin 方法来混入该库提供的防抖和节流函数，以便在组件中可以直接调用这些函数。 一些便于理解的比喻🍭 防抖就是公交车等人上车，有人上等5s，5s内又有人上再等5s / 节流就是公交车固定15分钟一班车 把防抖记成小哥送外卖，有新的单子来了先等五分钟，如果五分钟之内有新的单子，再等五分钟，直到五分钟之内没有单子，出门送外卖，也就是执行一次函数。希望对你理解有帮助 总结防抖和节流的区别在于它们控制函数执行的时机不同。防抖的基本思想是当事件被触发后，不立即执行事件处理函数，而是等待一段时间后再去执行。如果在等待时间内再次触发该事件，则重新计时。而节流的基本思想是当事件被触发后，先判断当前是否有等待执行的延时函数。如果有，就不执行事件处理函数；如果没有，就设置一个延时函数，在延时时间之后再去执行事件处理函数。","link":"/2023/02/15/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"title":"解决React组件样式污染","text":"在我用React写社区项目，利用浏览器开发工具进行调试时，偶然想到了样式污染的问题。在Vue中，我们可以给style标签添加scoped属性，解决样式污染的问题： 每个组件都会被赋予一个唯一的[data-*]属性，CSS也会随之添加对应选择器： 那么在React中，该如何解决类似的问题？网上有许多方法，在此我尝试了其中两种较主流的方法。 1.styled-components 首先我们需要安装它 yarn add styled-components or npm install --save styled-components 举一个简单但能体现特性的例子 123456789101112131415161718192021222324252627import React, { Component, Fragment } from 'react';//引入styled-componentsimport styled from 'styled-components'//修改了div的样式const myTitle = styled.div` font-size: ; color:red;`// 修改了button的样式const Button = styled.button` border:none; background-color:blue;`class App extends Component { render() { return ( // 使用Fragment标签可以仅包裹但不添加额外节点 &lt;Fragment&gt; &lt;Title&gt;标题&lt;/Title&gt; &lt;Button&gt;按钮&lt;/Button&gt; &lt;/Fragment&gt; ) }}export default App; 然后我们就能看到意料之中的结果 同时我们可以看到，styled-components给元素设置了某种规范的并且是随机的className，从而避免了样式污染。 但经过初步使用后，我并不喜欢这种解决方式（大概是因为在js里写css没有代码提示…），于是我开始尝试另一种方法。也是我最后选择的方法，CSS modules。 2.CSS modules使用方法：[https://www.w3cplus.com/react/css-modules-in-react.html] 我按照上述网站的方法进行了一系列配置，最终也得到了正确的结果，但似乎哪里有些差强人意。。。 CSS modules自动生成的className太长了。。。虽然对使用者来说不会有任影响，但对于常用开发者工具的开发者来说，至少对我来说，这实在是太糟糕了。我希望他能只留下最后的hash。然后我翻遍了google/baidu/CSDN/Stack Overflow/React官网/github issues等网站🐵查阅了许多资料，重启了n次服务器，最终还是没能解决问题。在网上看到最多的就是对css-loader中localIdentName属性的设置，但我尝试在各种位置设置，都没有用，于是我逆向查找到了引用这个属性的方法。。。 可以看到，localIdentName是灰色的，这代表在后面的函数体中并没有使用到这个属性，只使用到了localName 接下来就简单了，重新拼接出自己想要的字符串就行了，但这里最好的办法还是先判断是否传入localIdentName，将localName作为默认值，根据if返回结果，我想这也是作者的初衷。 好在最终得到了想要的结果(￣▽￣)~*","link":"/2020/09/09/%E8%A7%A3%E5%86%B3React%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81/"},{"title":"解构赋值","text":"什么是解构赋值? 解构（destructuring）是ES6中新增的概念，这是将一个数据结构分解为更小的部分的过程。 某些应用场景中，当我们想要往函数中传入多个参数时，通常会这样做： 123456function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender;}var p1 = new Person('wee', 18, 1); 如果我们只需要一个实例，那并不能看到什么问题。但如果我们想要创建多个实例，而且包含相同的参数，这样无疑增加了代码冗余。 接下来我们尝试一下用对象控制传参数： 12345678910111213var person = { name: 'wee', age: 18, gender: 1}function Person(obj) { this.name = obj.name; this.age = obj.age; this.gender = obj.age;}var p1 = new Person(person);person.name = 'boy';var p2 = new Person(person); 此时，虽然我们可以使用一个对象控制传参了，但构造函数内部的代码量变多了，而且看上去着实不太美观。 那么有没有什么办法可以改善这种情况呢？我们可以使用解构赋值： 12345678910111213var person = { name: 'wee', age: 18, gender: 1}function Person({name, age, gender}) { this.name = name; this.age = age; this.gender = gender;}var p1 = new Person(person);person.name = 'boy';var p2 = new Person(person); 可以看到，我们使用解构，在构造函数内部使用参数之前，针对性地将传入对象“分解”，而不用再在内部逻辑中从对象取值。","link":"/2020/08/18/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"解读关键字&quot;new&quot;","text":"Author: Wee Chou 在new的过程中到底发生了什么？请先看下面的例子： 1234function Person(){}var person0 = Person() // undefinedvar person1 = new Person() // {} 在平日的开发中，我们对函数的调用无非有两种方法： 直接调用 使用new初始化函数 在上述例子中，我们可以很快理解直接调用返回undefined的原因，因为Person函数没有返回值。但为什么new Person()会返回一个空对象？这就涉及到构造函数的知识了。 那么什么是构造函数？ 我们知道Javascript和其他基于类的语言不同，他是基于对象的，在该语言中没有类的概念（ES6中的“类”也只是语法糖）。那么在Javascript中，我们如何创建对象呢。这就用到了构造函数。 123456function Person(name) { this.name = name;}var person = new Person('wee');console.log(person.name); // wee 这就是一个最简单的构造函数。 现在我们又会疑惑，里面的this是什么？ 我们创建对象，就需要结合this和new。 123function A() { //return this;} 其实，当我们使用new初始化一个函数时，函数内部会隐式返回一个this，如果我们把他想象成一个空对象，就很好解释了。 123456function A() { var obj = new Object(); // 在内存中创建一个空对象 return obj;}var a = new A(); // a指向obj 而赋予this属性和方法，其实等同于赋予这个空对象属性和方法。 12345678function A(name) { var obj = new Object(); obj.name = name; return obj;}var a = new A('wee');console.log(a.name); // wee 而这，就是传统的利用工厂模式创建对象。而利用this，就是构造函数模式创建对象。 那么言归正传，new的过程中到底发生了什么? 12345678910111213141516171819202122232425function A(){}function B(){ this.name = 'wee'; return this; // 显式返回}function _new(func){ var obj = new Object(); var result = func.call(obj); // 将this指向obj // 判断此时func的返回值，若为对象，则返回result，否则返回obj var _result = function() { if (typeof result == 'object') { return result; }else { return obj; } } return _result();}// var a = new A();// 等同于console.log(_new(A)); // {}// var b = new B();// 等同于console.log(_new(B)); // {name:'wee'} 我们可以看到，A中没有返回任何对象，通过_new(A)返回了一个空对象；B中返回了一个对象，则最后的返回结果就为该对象。","link":"/2020/08/07/%E8%A7%A3%E8%AF%BB%E5%85%B3%E9%94%AE%E5%AD%97-new/"},{"title":"闭包","text":"Author: Wee chou 什么是闭包?许多开发者会因为“闭包”中的“包”想当然地以为只有被包裹才算闭包，比如函数内部“包”个函数，再在内部函数返回外部函数的局部变量。其实形成闭包的条件很简单。 1234var local = 0;function foo() { local++;} 是的，这就形成了一个闭包。形成闭包的条件： 内部函数访问外部函数参数 下面举一个经典的例子: 1234567891011121314function foo() { var local = 0; // 对于foo来说是局部变量 function bar() { local++; // 对于bar来说是外部变量, 此时访问了外部变量local console.log(local); } return bar; // 返回闭包到全局}var func = foo(); // 全局变量在执行过程中不会被回收(?)func(); // 1func(); // 2func(); // 3 就像这个例子里写的，我认为运用闭包最多的场景，就是隐藏变量，即无法在外部直接修改local。 &nbsp;&nbsp;&nbsp;&nbsp;例子中，唯一可以直接访问到local变量的，只有内部函数bar，当bar执行完毕后，会销毁自身，而bar中的局部作用域会释放到foo中，由于我们在全局引用了foo函数，使foo在执行完毕后并没有被立即销毁，又因为在foo中返回了内部函数bar，使得我们可以在全局持续访问并执行bar的内部操作，并保留foo的局部作用域，直到func不再被访问后被回收。 所以闭包只是一个定义，并不是设计者特意由设计出来的","link":"/2020/08/10/%E9%97%AD%E5%8C%85/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"debounce","slug":"debounce","link":"/tags/debounce/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"issues","slug":"issues","link":"/tags/issues/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"redux-saga","slug":"redux-saga","link":"/tags/redux-saga/"},{"name":"Vue-cli2.x","slug":"Vue-cli2-x","link":"/tags/Vue-cli2-x/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"vite","slug":"vite","link":"/tags/vite/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"vdom","slug":"vdom","link":"/tags/vdom/"},{"name":"Diff","slug":"Diff","link":"/tags/Diff/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"CSS module","slug":"CSS-module","link":"/tags/CSS-module/"},{"name":"less-loader","slug":"less-loader","link":"/tags/less-loader/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","link":"/tags/ECMAScript-6/"},{"name":"new","slug":"new","link":"/tags/new/"}],"categories":[{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Flask","slug":"Flask","link":"/categories/Flask/"},{"name":"节流防抖","slug":"Javascript/节流防抖","link":"/categories/Javascript/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"name":"性能优化","slug":"性能优化","link":"/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Mac OS","slug":"Mac-OS","link":"/categories/Mac-OS/"},{"name":"ToDoList","slug":"React/ToDoList","link":"/categories/React/ToDoList/"},{"name":"event","slug":"Javascript/event","link":"/categories/Javascript/event/"},{"name":"作用域","slug":"Javascript/作用域","link":"/categories/Javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"models","slug":"Flask/models","link":"/categories/Flask/models/"},{"name":"front end issues","slug":"front-end-issues","link":"/categories/front-end-issues/"},{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"},{"name":"redux-saga","slug":"React/redux-saga","link":"/categories/React/redux-saga/"},{"name":"原型","slug":"Javascript/原型","link":"/categories/Javascript/%E5%8E%9F%E5%9E%8B/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Create React App","slug":"React/Create-React-App","link":"/categories/React/Create-React-App/"},{"name":"应用推荐","slug":"Mac-OS/应用推荐","link":"/categories/Mac-OS/%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90/"},{"name":"async","slug":"Javascript/async","link":"/categories/Javascript/async/"},{"name":"虚拟dom","slug":"React/虚拟dom","link":"/categories/React/%E8%99%9A%E6%8B%9Fdom/"},{"name":"Hook","slug":"React/Hook","link":"/categories/React/Hook/"},{"name":"解决样式污染","slug":"React/解决样式污染","link":"/categories/React/%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E6%B1%A1%E6%9F%93/"},{"name":"ES6","slug":"Javascript/ES6","link":"/categories/Javascript/ES6/"},{"name":"new关键字","slug":"Javascript/new关键字","link":"/categories/Javascript/new%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"闭包","slug":"Javascript/闭包","link":"/categories/Javascript/%E9%97%AD%E5%8C%85/"},{"name":"start","slug":"Nuxt/start","link":"/categories/Nuxt/start/"},{"name":"Vue-cli2.x","slug":"Vue/Vue-cli2-x","link":"/categories/Vue/Vue-cli2-x/"},{"name":"Vue3","slug":"Vue/Vue3","link":"/categories/Vue/Vue3/"}]}