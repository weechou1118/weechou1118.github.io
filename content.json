{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"2022从9.16开始转移到这","text":"2022从9.16开始转移到这9.16无 10.12 一些git 的高级用法 git reflog介绍：用来查看你的所有操作记录。 123430ffd23df4 (HEAD -&gt; hotfix/v4.58.1, origin/hotfix/v4.58.1) HEAD@{0}: reset: moving to HEAD30ffd23df4 (HEAD -&gt; hotfix/v4.58.1, origin/hotfix/v4.58.1) HEAD@{1}: pull --tags origin hotfix/v4.58.1: Fast-forward7ffbb01b45 HEAD@{2}: pull --tags origin hotfix/v4.58.1: Fast-forward80e253f34e HEAD@{3}: pull --tags origin hotfix/v4.58.1: Fast-forward 使用场景：配合git reset —hard commitId，可以实现比较灵活的版本跳转 10.13 逛下掘金 图片压缩好网站: https://tinypng.com/ 10.14 最后一天班,得好好学一天 📍跟着教程了解一下SEO搜索引擎的实现原理是爬虫。爬虫能够有效跟踪页面之间的链接，以查找要添加到索引中的新内容。使用搜索引擎时，将从索引当中提取相关结果，并用算法给其进行排名。 结果发现是广告，那就不做笔记了，随便看看吧🐶 递归组件相关的知识，可以看一下，好像很神奇 https://blog.csdn.net/sinat_17775997/article/details/110918047 📖前后端分离→CSR，对应服务端渲染→SSR ⚠️以后不要因为复杂度的原因跳过eslint扫描了，不然以后别人在这个分支下提交代码都会有复杂度的报错 10.18 摸鱼day, 改了一些bug, 虽然还是没啥活, 试着用平常心去对待吧 10.19 话不多说，有时间还是多看看书把。然后等滑板到了， 务必玩起来，说不定能够成为，比羽毛球更适合自己的运动。 📍鉴权相关的代码，本质就是最后是return true还是false https://juejin.cn/post/7129298214959710244 这个也可以看，写得不错 10.21 学习 ⭐️制订长期学习计划 早晨起来了解实事/各种论坛 逛一下掘金啥的，学习专业技能，看看别人写的优质代码 中午休息一下打两把游戏，吃饭顺便看动漫/辩论赛/综艺下饭 下午出门看书？或者运动 看电影/动漫 游戏 睡前尽量看书吧 冥想，思考今天经历的一切，感受体内气息的流动 睡觉 什么是webhook？ 类似api，都是两个应用程序之间同步和中继数据的方式 和api的区别：在发出请求的方式上有所不同。例如，无论是否有数据更新响应，API 都会调用数据。而 webhook 仅在您连接的外部系统有数据更新时才通过 HTTP POST 接收调用。 10.24 学习 果某个key不固定，可以把key抽成一个变量，用[key]的方式作为key 1234567const CUSTOM_KEY = 'CUSTOM_KEY_ONE'const obj = { [CUSTOM_KEY]() { console.log(11) } }obj.CUSTOM_KEY_ONE() xbb水印做法：在getUserInfo执行时执行创建水印的方法，原理是创建一个canvas，渲染水印内容，转成base64后插入到div的backgounrd-image里面 10.26 业务代码尽量不要写到通用组件里面 【CSS】如果忘记了flex相关的属性，可以在此方便看到，还能够进行调试 bilibili弹幕不遮挡人像实现方式 关键属性mask-image、mask-size（注意要加兼容前缀比如-webkit-） 遮罩层的图像会实时计算（应该做了防抖，不然这个性能消耗也太大了）。像b站的话会生成一个svg+xml;base64格式的图片，然后结合上面提到的属性由浏览器解析成遮罩层实现遮挡效果 好用的时间库：Moment（有点重，dayjs更轻量）、Date-FNS 🟩前端测试工具有时间接触一下？ 10.27 学习一下如何配置完好的代码校验，上完线再看Q4的东西，周末没事可以来公司卷一下？ npm模块 功能介绍 husky git的钩子，在git的hook中执行一些命令 lint-staged 对git暂存的文件进行lint检查 eslint js代码检测工具 prettier 代码格式化模块 CodeMetrics（vscode插件） 复杂度计算 eslint+prettier 最终目的是为了统一编码习惯，方便在协同开发的过程当中降低他人代码难度从而提高开发效率 prettier 首先得装个prettier插件 在package.json同级根目录新建一个.prettierrc文件，内容：1234567891011121314{ \"printWidth\": 100, \"tabWidth\": 2, \"useTabs\": false, \"semi\": false, \"singleQuote\": true, \"quoteProps\": \"as-needed\", \"jsxSingleQuote\": false, \"trailingComma\": \"none\", \"bracketSpacing\": true, \"bracketSameLine\": false, \"arrowParens\": \"always\", \"endOfLine\": \"lf\"} 但是不适用于vue中&lt;template&gt;中的内容，这个时候我们可以结合eslint加强对规范的管理 eslint 首先当然是安装eslint 通过eslint init初始化.eslintrc.js（但通常不这么做，通过init生成的文件规则太复杂了，自己新建一个文件写上常用的规则就好） 然后就可以进行校验啦。单个文件手动校验可以通过eslint [path]命令，但我们不可能每次修改完文件都去手动执行命令校验一次代码规范，所以我们可以结合husky和lint-staged husky 在package.json中配置 12345\"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" }}, 可能是版本问题，husky v8似乎需要手动补充命令才可以正常运行 https://blog.csdn.net/qiphon3650/article/details/125674339 lint-staged 在package.json中配置 1234567\"lint-staged\": { \"src/**\": [ \"prettier --config .prettierrc --write\", \"eslint --fix\", \"git add\" ]} CodeMetrics 直接在vscode插件商店中安装即可 安装后它会实时计算方法体的复杂度，并用俏皮的语言告诉你复杂度高还是低 10.28 黑白滤镜1filter: grayscale(100%); 11.10断点续传实现流程有时间可以看一下 11.16 图片拖拽难点（也不难，主要是找到解决办法花了好久，索引能力还需提高）总结（vueDraggable + el-upload） 因为el-upload中的图片列表被封装在el-upload组件内，所以被办法通过直接包裹图片列表的方式达成拖拽条件 这里的实现方法是，先给el-upload设置show-file-list=”false”，再自己额外添加一层拖拽层，可以直接使用element的类样式。然后在自己创建的图片列表外包裹一个VueDraggable标签即可 11.18总线相关的知识可以补充一下 本质就是在不同组件下引用同一个Vue实例，然后利用该实例的$on和$emit实现事件的监听和触发 11.21具名插槽 父容器： 子组件 【小工具】词云 11.24 📍在加组件之前，先看一下组件之间层级关系，如果有耦合业务的组件尽可能将组件作为父子关系，否则数据传输会很麻烦（bus/vuex） 11.30📍开发之前注意嵌套结构，不然后面容易出问题 12.8 哪怕是简单的切图也要尽可能做到百分百复刻，像素级还原，不要嫌麻烦 12.9🫡依照自己的步调走，脚踏实地，别想着一步登天；多看看别人的代码，学习一些优雅的写法。 🫡工作的时候好好工作，下班之后好好玩","link":"/2022/12/10/2022%E4%B8%8B%E5%8D%8A%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%97%A5%E8%AE%B0/"},{"title":"Flask入门 ---- models","text":"flask1.1python3.7 Flask-SQLalchemy flask的ORM模型使用ORM模型的原因当项目越来越大时,会出现很多问题 如果原生SQL较多 重复使用率低 如果你的数据库发生改变 所有的原生SQL就都要修改 写原生SQL的时候 会有安全隐患 ORM：中文件关系对象的映射 使用ORM去操作数据库的时候 不会再去写原生的SQL了 通过把表映射成 类 字段为你的属性 ORM在执行的时候 也会最终转换为 SQL语句 去操作数据库 易用性 使用ORM可以减少重复SQL的概率 写出来的模型也更加的直观清晰 可移植性 ORM支持很多不同的数据库 安装sudo pop3 install flask-sqlalchemy 一、执行原生SQL 创建数据库create datebase if not exists 库名 character set utf8 安装pymysqlsudo pip3 install pymysql 配置数据库SQLALCHEMY_DATABASE_URI = ‘mysql+pymysql://用户名:密码@主机:端口号/库名’ 实例（从对象中读取配置） 1234567891011121314151617`config.py`class Config(object): '''项目的应用配置类''' DEBUG = True # SQLALCHEMY_DATABASE_URI = \"mysql://root:1234@192.168.31.180:3306/dy\" SQLALCHEMY_TRACK_MODIFICATIONS = False SECRET_KEY = \"DylqFbqxp5ArVPmzd1D/DuhSIszWjtzTxL4LUktID7mvsb6s75ENhRTbZUBikRqV/vPPmUrF4yvuEruzs/K+/A==\" SQLALCHEMY_COMMIT_ON_TEARDOWN = True# 产品线上使用：class Config_Project(Config): DEBUG = False SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/dyinfo?charset=UTF8MB4\"# 线下环境使用class Config_Devlopement(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:89974037zxc@localhost:3306/HelloFlask?charset=UTF8MB4\"config_dict = {'product': Config_Project, 'develop': Config_Devlopement} 123`manage.py`app = Flask(__name__)app.config.from_object(config_dict['develop']) 当前字段类型 类型名 说明 integer 整形 SmallInteger 小整形 BigInteger 长整型 Float 浮点型 String varchar类型 Text 长文本 Boolean tingint Date 日期 datetime.date Time 时间 datetime.time DateTime 时间和日期 datetime.datetime 约束条件 选项 选项说明 primary_key 主键 默认False index 常规 默认 False Unique 唯一 默认 False nullable 是否为null 默认True default 默认值 注意其中的default默认值 并不是更改表结构的默认值 而是在插入数据的时候 如果不插入数据 则插入默认值 实例配置1234567from flask import Flaskfrom flask_script import Managerfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)# app中间配置在上个代码块有写db = SQLAlchemy(app)manager = Manager(app) 创建模型12345class User(db.Model): id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') 数据的添加修改删除123456789101112131415161718# 创建蓝图，目的是把一个应用分解成一个蓝图的集合MainView = Blueprint('bp',__name__)PetView = Blueprint('pet',__name__)@MainView.route('/createdb')def create_table(): db.drop_all() # 删除与当前模型类同名的表 db.create_all() # 创建当前模型类的表 return '表创建成功'@MainView.route('/adduser/&lt;string:name&gt;')def adduser(name): user = User() user.username = name user.save() return f'添加成功username={name}' 目录结构树123456789101112131415161718192021222324project/ App/ __init__.py static/ js/ img/ upload/ css/ templates/ common/ ... forms/ __init__.py ... models/ __init__.py views/ __init.py__.py ... settings.py email.py extensions.py manager.py migrations/ 三、数据的操作创建模型类12345678910class User(Base,db.Model): __tablename__ = 'user' #给表起名 id = db.Column(db.Integer,primary_key=True) username = db.Column(db.String(20),index=True) age = db.Column(db.Integer) icon = db.Column(db.String(40),default='default.jpg') def __init__(self,username='',age=0,icon='default.jpg'): self.username = username self.age = age self.icon = icon 添加 add add_all添加一条123456@main.route('/add/')def add(): u = User(username='张三',age=18) db.session.add(u) db.session.commit() return '数据添加一条成功' 添加多条1234567@main.route('/add_all/')def add_all(): u1 = User(username='李四',age=20) u2 = User(username='王五',age=22) db.session.add_all([u1,u2]) db.session.commit() return '添加多条' 自定义增删改查的基础类1234567891011121314151617181920212223class Base: # 定义一个添加一条数据的方法 def save(self): try: db.session.add(self) db.session.commit() except: db.session.rollback() # 定义添加多条数据的方法 @staticmethod def save_all(*args): try: db.session.add_all(args) db.session.commit() except: db.session.rollback() # 自定义删除方法 def delete(self): try: db.session.delete(self) db.session.commit() except: db.session.rollback() 四、数据库操作查询集查询数据的集合 分类 原始查询集 类名.query得到的结果就为原始查询集 数据查询集加上各种的过滤器的方法 最终返回的结果 为数据查询集 都是用数据查询集 过滤器all查询所有 以列表形式返回 不支持连贯操作类名.query.all() 12345@main.route('/all/')def all(): data = User.query.all() print(data) return xxx filter()过滤 返回的是sql语句 需要.all/.first一下 类名.query.filter([类名.属性名 条件操作符 值]) 默认返回所有，支持连贯操作 123# data = User.query.filter() #返回所有# data = User.query.filter(User.age&gt;20) #查询年龄大于20的数据data = User.query.filter(User.age&gt;20,User.age&lt;40) #查询年龄大于20的数据 and 小于40 filter_by只支持参数为关键字参数（）123# data = User.query.filter_by(id=2)# data = User.query.filter_by(id&gt;2) #错误写法data = User.query.filter_by(id=2,age=27) offset和limit组合使用类似分页 12data = User.query.offset(2).limit(2)# limit 2,2 order_by()排序12# data = User.query.order_by(User.age) #升序data = User.query.order_by(-User.age) #降序 get获取id对应的数据查询成功返回对象 查询失败 返回None 1data = User.query.get(2) 过滤条件1234# contains包含data = User.query.filter(User.username.contains('7'))# like模糊查询data = User.query.filter(User.username.like('%6')) #以6作为结尾的数据 startswith endswith 以…开头 以…结尾1data = User.query.filter(User.username.endswith('6')) in和not in1data = User.query.filter(~User.age.in_([27,12,1,30,40,50])) 参考: [https://segmentfault.com/a/1190000015240882]参考: [http://docs.jinkan.org/docs/flask/blueprints.html]","link":"/2020/05/19/flask%E5%85%A5%E9%97%A8/"},{"title":"React ToDoList","text":"编写一个ToDoList以巩固知识 index.js （入口文件，渲染页面） 1234567import React from 'react'// 提供DOM特定的方法，及页面渲染import ReactDOM from 'react-dom' // ToDoList 组件import ToDoList from './ToDoList'ReactDOM.render(&lt;ToDoList /&gt;, document.getElementById('root')) ToDoList.js（父组件） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 相当于// import React from 'react'// import {Component} from 'react'import React, {Component} from 'react'// webpack提供的导入语法import './styles.css'import Item from './item';class ToDoList extends Component { constructor (props) { // React中，使用props和state来跟踪变量 super(props) this.state = { inputValue: '', list: ['item1', 'item2'] } } render () { return ( &lt;div&gt; &lt;label htmlFor=\"inputItem\"&gt;inputItem: &lt;/label&gt; &lt;input value={this.state.inputValue} onChange={this.itemChange.bind(this)}/&gt; &lt;button onClick={this.addItem.bind(this)}&gt;click me&lt;/button&gt; &lt;ul&gt; { // 使用map遍历html元素 this.state.list.map((item, index) =&gt; { return ( // 向子组件传递content index delete自定义变量 &lt;Item key={item+index} content={item} index={index} deleteItem={this.deleteItem.bind(this)} /&gt; ) }) } &lt;/ul&gt; &lt;/div&gt; ) } itemChange (event) { // React 需要用setState来改变state，而不能直接改变state this.setState({ inputValue: event.target.value }) } addItem () { this.setState({ // ES6 剩余项语法... 类似解构 list: [...this.state.list, this.state.inputValue] }) } deleteItem (index) { var list = this.state.list list.splice(index, 1) this.setState({ // 相当于list: list list }) }}export default ToDoList Item.js (子组件) 12345678910111213141516171819202122// eslint-disable-next-lineimport React, { Component } from 'react';class Item extends Component { // props用于父子组件出传值 constructor (props) { super(props) // 使render中onClick事件对应方法调用时，this指向当前实例 this.handleClick = this.handleClick.bind(this) } render () { return ( &lt;li onClick={this.handleClick}&gt;{this.props.content}&lt;/li&gt; ) } handleClick () { this.props.deleteItem(this.props.index) console.log(this.props) }}export default Item 第一行的eslint-disable-next-line注释，可以使注释行的下一行不会ESLint检测","link":"/2020/08/26/React_ToDoList/"},{"title":"2023前端学习","text":"1.4啥是微前端？ 微前端就是可以一个页面跑多个 vue、react 甚至 jquery 等不同项目，它之间的 JS、CSS 相互隔离运行，不会相互影响，但也有通信机制可以通信。 其实也简单，一句话就可以说明白：当路由切换的时候，去下载对应应用的代码，然后跑在容器里。 1.5Vue当中的虚拟DOM工作原理（简述） 首先我们会将 html内容填入Vue文件的 &lt;template&gt; 标签当中 然后Vue中的render函数会将模板中的html内容转换成虚拟DOM【编译器模块】1234567891011121314// render 函数类似这样function render(h) { return h('div', 'hello') // return vnode}// 虚拟DOM，本质是一个Javascript对象{ tag: 'div', children: [ { text: 'hello' } ]} （如果在首次render之后改动html内容，Vue会将新的虚拟节点和旧的虚拟节点进行比较，最后以高效的方式在网页上更新，即只更新html变化的部分）【渲染模块】 最后Vue会将虚拟节点转化成真实DOM呈现在浏览器中 模块执行顺序（响应模块、编译器模块、渲染模块）【声明】模板，响应式对象 编译器模块将手敲的模板转化成渲染函数（render function） 使用响应式模块，初始化响应式对象 观察响应对象的变化，render函数会返回一个虚拟节点，然后在组件挂载阶段（渲染模块包括挂载mount阶段和补丁patch阶段，其中补丁阶段只用于更新，mount阶段用于初始化节点），调用mount函数，使用虚拟DOM节点创建web页面。 Dep → dependency 1.6 坑上午解决了一个大坑，表单初始化的时候，如果有富文本字段，滚动条会自动定位到富文本（vue-quill-editor组件）的位置。尝试了网上出现频率最多的.enable(false)→.enable(true)方法，但没有效果，最终打算手动置顶，但找了半天没找到滚动条所在的容器，无论怎么调整scrollTop都为0，找了半天发现这边用到了el-scrollbar组件，还是个官方文档没有的组件，用它的话，想要调整组件就需要用到实例方法refs.scroll.wrap.scrollTop = 0，然后在这里，通过provide/inject从富文本组件当中拿到了表单edit组件中的滚动容器组件，调用对应方法跳转至顶部 坑 在共用组件引入inject并取值，但没有考虑到其他没有注入对应参数的祖先组件 遇到意义不明的代码注释之前最好先问一下 1.9 paas业务看一下（自测） 子表单自测 待解决问题 表格内容变化导致单元格高度变化，操作按钮需要始终保持垂直居中 点击新建后下一个新建页默认值回显问题（有bugID） 英语学习cheat sheet 小抄 1.10子表单优化坑子表单优化需求大坑。在非全屏状态下需要给tbody表格体给一个最大高度，然后允许滚动，这里记录一下尝试过的多种解决办法以及最终实际应用的解决办法 参考： https://stackoverflow.com/questions/23989463/how-to-set-tbody-height-with-overflow-scroll （stackoverflow强无敌！！！） 表头thead需要固定 参考了web端列表表格体，发现表头和内容被分成了两个table，思路应该是没问题的，但需要解决其他繁琐的问题：表头和内容同步滚动、单元格宽度统一。由于没法简单解决所以pass掉了 给th设置一个position: sticky+top: 0即可 改变tbody和tr的结构，使得tbody可以滚动。但在系统当中衍生出了其他问题，所以也pass掉了，到时候自己写个demo试试12345678910111213141516171819table, tr td { border: 1px solid red}tbody { display: block; height: 50px; overflow: auto;}thead, tbody tr { display: table; width: 100%; table-layout: fixed;/* even columns width , fix width of table too*/}thead { width: calc( 100% - 1em )/* scrollbar is average 1em/16px width, remove it from thead width */}table { width: 400px;} 漂浮的操作按钮需要跟着表单内容一起滚动 ✅漂浮按钮绝对定位，外层容器不给任何的相对定位（然后神奇的是居然达到了我要的效果，这里的原理还需要研究一下 TODO），遍历DOM节点，动态修改按钮的margin-top  给父元素一个相对定位，纵向滚动跟踪是解决了，但横向滚动会出问题，按钮会跟着相对定位元素一起滚动，而我们需要按钮固定在行右边 1.11深拷贝场景在做子表单的时候想缓存下表单默认值的数据，但对于引用类型取值，需要考虑运行时是否在其他地方也修改了数据，如果修改了，可能会导致打印出来的值并不是我想要的值，哪怕是这样 1234567891011this.selectedSubData = { subId: guid()}console.log(this.selectedSubData) // 打印出来的并不是我上面赋的值// 感觉原理有点类似这个for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i); // 打印了5次 5 })}; 总结 想要获取当前值：深拷贝 想要获取最后的值：setTimeout/啥也不加 这边具体还是问一下大佬吧 1.12什么时候需要用到call、apply、bind首先巩固一下this 相关的知识 说白了this就是一个变量，跟自己声明的变量一样，指向一个对象 call和apply区别仅在于第二个参数的接收类型，因为apply的第二个参数接收数组，所以比较常见的是处理数组时与Array.xxx搭配使用 this指向和函数调用者有关，分以下几种情况123456789101112131415161718192021// 假设在浏览器控制台中执行，在node环境中没有window对象，this默认指向undefined// 声明一个普通函数function func() { console.log(this)}func() // this -&gt; window。因为这边func挂载在window上，由window隐式调用const obj = { a: 1, // 在对象内声明一个普通函数 func: function() { cosnole.log(this) }, // 在对象内声明一个箭头函数 func_arrow: () =&gt; { cosnole.log(this) }}obj.func() // this -&gt; obj。因为这边func挂载在obj上obj.func_arrow() // this -&gt; window。箭头函数的this指向和函数的调用者保持一致，这边obj挂载在window上，所以this指向window 使用场景 之前只是了解了一下用法，但是技术需要附着到业务上才能体现价值，所以提供使用场景非常重要 例子1： 123456789101112131415161718192021const obj = { func_in_cb: function() { console.log('lalala') } func: function(cb) { cb() // 这里相当于一个自执行函数，始终指向最外层对象window // (function() { // this.func_in_cb() // })() // 所以需要手动将this指向obj， cb.call(this) } test: function() { this.func(function() { this.func_in_cb() }) }}obj.test() 例子2： 123456// 将类数组元素转化成数组，继而拥有数组的方法function test() { const args = Array.prototype.slice(arguments, 0) return args}test(1, 2, 3) // 返回[1, 2, 3] 例子3： 12345678910const arr = [1,2,3]const elements = ['a', 'b']arr.push(elements) // 这样直接push的话arr会变成[1, 2, 3,['a', 'b']]// 如果我们想要使用push达到扁平数组的效果，可以用到扩展运算符arr.push(...elements)// 或者使用apply，这里第二个参数接收一个数组arr.push.apply(null, elements)// 其他例子Math.max.apply(null, elements) // 3 例子4： 123456789// call 构造函数链/继承场景function Food(price, taste) { this.price = price this.taste = taste}function Pizza(price, taste) { Food.call(this, price, taste) this.category = 'pizza'} 1.13SDK和API的区别SDK：饮料机的饮料仓  API：饮料机的水龙头 1.29英语学习finish work 下班 finish school 放学 ten to eleven 十一点还差十分钟 ten past eleven 十一点十分 1.31 有的文章/课程比较小众，要结合当下情况判断需不需要花时间去看 【RECORD】使用断点调试Vue项目神光小测里的调试秘籍大部分内容讲的是较为深入的源码调试技巧，不太适合现在的我，记录下一些相对简单的、现阶段用得到的调试技巧 环境参数 @vue/cil ⇒ 5.0.8（相关依赖有node版本限制） node ⇒ v14.20.1（此处使用nvm控制，发现各个版本的npm包管理也是独立的，不同版本之间互不影响） IDE vscode （用vue-cli4不会生成vue.config.js，需要手动配置） 关键步骤 在运行和调试中创建调试配置文件 指定目标url 在代码中插入debugger进行调试 （这里使用localhost可能会无法访问页面，具体原因不清楚） 点击按钮开始调试后，就能够开始断点调试了 IDE中 浏览器中 防抖和节流的区别以点击按钮触发事件为例 防抖：延迟时间设置为5秒，10秒点5下，在第五下结束后如果不再继续点的话，事件会在10+5=15秒后执行 节流：间隔时间设置为5秒，10秒内持续快速点击，第5秒的时候会触发一次事件，第10秒的时候会触发一次事件 有时间手写实践一下 2.1好文：Vue状态管理与SSR详解https://blog.csdn.net/CRMEB/article/details/123223075 2.4实现一个min-vue-router 关键在于三行代码 1234567// 监听页面初始化 === window.onloadwindow.addEventListener('load', this.refresh, false)// 每当激活同一文档中不同的历史记录条目时，popstate 事件就会在对应的 window 对象上触发// === window.onpopstatewindow.addEventListener('popstate', this.refresh, false)// 根据当前url中的hash值在对应DOM中插入对应组件document.querySelector('#content').innerHTML = curRoute.component 2.9h函数h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的。 啥是SFC简而言之就是.vue文件。官方解释：一个 Vue 单文件组件 (SFC)，通常使用 *.vue 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。 2.13vscode工作区隔离工作区，可以让插件区分应用场景 2.15使滚动条不占空间方法一：给scroll容器加个属性overflow: overlay ，完美解决问题，但兼容性不行 方法二：  // TODO 2.19display: block 和 width: 100%display: block 和 width: 100% 并没有直接联系，块级元素会自适应占满整行，指的是横向的剩余空间，而设置width最后生效的宽度是相对于父容器而言的 inline-flex同时拥有flex的特性和block特性 ts中的?.可选链，就是代码运行时如果遇到 null 或 undefined 就可以⽴即停⽌某些表达式的运⾏，直接返回undefined 12345678910const obj = { foo: { bar: { baz: 42, }, },};const baz = obj?.foo?.bar?.baz; // 42const safe = obj?.qux?.baz; // undefined 2.21异步组件，分包异步组件1234Vue.component('async-example', () =&gt; import(/* webpackChunkName: \"async\" */ './components/asyncCompo.vue'))// 注释可以定义最终生成的包名[name] 分包通过上述方式异步引入的组件，会被打入额外的包，而不是打入主包 命名通过vue-cli3生成的项目没有包含webpack.config.js配置文件，但可以直接在vue.config.js中进行修改 2.23vue3中解构props失去响应式的解决办法 解构后用computed/ref/reactive包裹每一个元素 直接用toRefs(props)生成一个新的响应式对象 可以用opacity代替状态颜色设置Array.from妙用把类数组转换为数组，使其能够使用数组的方法 通过querySelectorAll(‘ *‘)获取所有DOM节点2.26同步任务，异步任务（宏任务，微任务）执行顺序。题解 首先script代码段本身是最外层的宏任务，先执行其中的同步任务，输出 // Y 0 然后清空该宏任务下的微任务，也就是四个promise // 5 6 7 8 Prom中的await同样是个微任务，所以输出 // X 然后执行其他宏任务，并以同样的顺序执行 同步任务→ 宏任务→ 微任务 // 1 2（第一个setTimeout）3 4（第二个setTimeout） 所以最后输出 // Y 0 5 6 7 8 X 1 2 3 4 2.27好用但不常用的方法 Object.entries(Object) [{ name: ‘zw’, age: 18 }] → [[ ‘zw’, 18 ]] Array.from(类数组) DOM列表，proxy对象列表 ⇒ 数组（继承数组方法） 3.1!. 非空断言github.dev 3.3！！computed对象可以直接赋值，并触发set方法","link":"/2023/03/03/2023%E5%89%8D%E7%AB%AF%E6%97%A5%E8%AE%B0/"},{"title":"promise与异步编程","text":"","link":"/2020/08/18/promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"title":"macOS上值得推荐的常用软件","text":"Author: Wee Chou@E-mail: saioukbed@qq.com Note:转载请注明本文出处链接、作者 以下所推荐的 Apps &amp; 服务，都是十分挑剔的本人在使用过许多同类应用后，所筛选出来的自认为真正可以改善生活品质或工作效率的应用 pap.er Pap.er 是一款专门为 macOS 设计的精美壁纸应用，每天更新全球最新高清壁纸；适合喜欢寻找壁纸来改变心情的你。 为什么推荐? 每天更新来自全球的高清(4k,5k)壁纸。 便捷预览壁纸功能：通过缩略图可预览壁纸，能够快速浏览众多壁纸。 强大的即用即设壁纸功能：看到喜欢的壁纸，一键就能设置成为当前桌面壁纸。 壁纸管理便捷：下载过的壁纸，我们贴心的存放到了下载目录，通过应用内直接打开就可以管理。 无广告！无广告！无广告！ =====(づ′▽`)づ ===== IINA IINA 基于 mpv，为最新 Mac 系统而生，支持 Touch Bar、兼容 MPV 脚本、几乎支持所有格式、网络播放，是一款拥有优雅外观的视频播放器。 为什么推荐? 更快和更稳定的解码效果 丰富的设置项 0.25x~16x变速 支持dark mode 免费 开源 无广告 =====(づ′▽`)づ===== Alfred Alfred 这是一款被称之为Mac效率神器的App，有了Alfred 你甚至无需鼠标就可以实现各种操作，包括出发各种文件、网络操作，其UI界面使用方便，而且不是通过命令来实现，是开发者们和键盘刘童鞋们的神器，比之此前类似的软件——Pack和Power来说完全是秒杀的节奏。 应用介绍 这是最基本的了，option+空格激活以后，输入关键字就开始搜索，默认会匹配已经安装的应用软件，我还设置了搜索Safari书签。如果无法匹配，那么会出现搜索google之类的选项，直接触发打开浏览器到搜索引擎搜索。 和Spotlight直接搜索各种类型不同，Alfred要多敲一个空格或者单引号来指示它搜索文件名。实际使用中，我觉得这样更方便和快捷，alfred几乎是秒出结果，而spotlight在迅速反馈结果的同时，有个逐步增加的过程。就对文件的实际搜索效果来说，alfred对文件名的模糊搜索是OK的，但不如Devonthink连文件内容一概通杀的彪悍。当然，DT的彪悍也是在你索引以后的结果，各有专长吧。Spotlight感觉居中，支持文件内容搜索，但仍然不如DT彻底。顺便说一句，DT这几天在促销，可以看这里。 估计键盘流里很多是所谓geek吧，所以alfred支持直接一个“&gt;”后，打开终端执行命令行。 alfred还贴心的支持了和1password的整合。 强力功能需付费!","link":"/2020/05/12/macOSapps/"},{"title":"函数的作用域、作用域链以及return关键字","text":"作用域全局作用域：在函数外部使用var关键字定义的变量局部作用域：在函数内部使用var关键字定义的变量 特点： 局部变量无法直接影响全局变量 在局部作用域中可以使用全局作用域的变量 作用域链函数内部变量在进行查询时，遵循的规则： 首先从函数自身所在的作用域进行查找 若没有，则向父级或者是先辈作用域进行查找 若没有，最终的值就是undefined 局部变量影响全局变量的方法 在函数内部不使用var关键字定义变量 使用return关键字将局部变量的值返回到函数外部，必须使用对应的变量进行接收 return关键字作用 将函数内部变量的值返回到函数外部 return关键字后面的程序不再执行 转载自: [https://www.cnblogs.com/sherryStudy/p/function_field.html]","link":"/2020/08/10/%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%BB%A5%E5%8F%8Areturn%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"使用react-saga","text":"redux-saga是一个Redux中间件，我在日常的开发中，将它作为发送异步请求的组件。 我认为它的根本作用是降低耦合度，因为在生命周期函数中我们同样可以发送并接受异步请求/结果 用户发出Action，Reducer计算出新的state，view重新渲染。像这样立即算出state的是同步的操作。 redux中的数据流大致是： UI——&gt;action(plain)——&gt;reducer——&gt;state——&gt;UI\\ redux遵循函数式编程的规则，上述的数据流中，action是一个原始js对象(plain object)且reducer是一个纯函数，对于同步且没有副作用的操作，上述的数据流起到可以管理数据，从而控制视图层更新的目的。 但是如果存在副作用，比如ajax异步请求等等，那么应该怎么做？\\ 如果存在副作用函数，那么我们需要首先处理副作用函数，然后生成原始的js对象。如何处理副作用操作，在redux中选择在发出action，到reducer处理函数之间使用中间件处理副作用\\。 redux增加中间件处理副作用后的数据流大致如下： UI——&gt;action(side function)——&gt;middleware——&gt;action(plain)——&gt;reducer——&gt;state——&gt;UI\\ 在有副作用的action和原始的action之间增加中间件处理，中间件的作用就是：转换异步操作，生成原始的action，这样，reducer函数就能处理相应的action，从而改变state，更新UI。\\ redux-saga的基本使用 配置中间件 src/store/index.js 123456789101112131415import { createStore, applyMiddleware } from 'redux'import reducer from './reducer'import createSagaMiddleware from 'redux-saga'import rootSaga from './saga'const sagaMiddleware = createSagaMiddleware() // 创建中间件export const store = createStore( reducer, // 挂载 applyMiddleware(sagaMiddleware))// 执行sagaMiddleware.run(rootSaga) saga.js src/store/saga.js 123456789101112131415161718192021222324252627282930313233343536import { call, put, takeEvery } from 'redux-saga/effects'// 用于存放action type 常量import { GET_HOME_LIST } from '../pages/home/store/contants'// function* 生成器函数，他将返回一个Generator对象function* getHomeList(action) { // fetch是ES6提供的原生方法 const p = () =&gt; fetch([your url],{ method: 'GET' }) // 比axios多了这一步 .then(res=&gt; res.json()) .then(res=&gt;{ if (res.success) { return res.data }else { console.log('网络请求失败') } }) // 用call接受p异步函数返回的结果 const res = yield call(p) // 触发success action并带上异步结果 yield put({ type: GET_HOME_LIST_SUCCESS, payload: res })}function* rootSage() { // getHomeList指上面的getHomeList生成器函数 yield takeEvery(GET_HOME_LIST, getHomeList)}export default rootSage 3.reducer.js src/store/reducer.js 12345678910export default (state = defaultState, action) =&gt; { switch (action.type) { case GET_HOME_LIST_SUCCESS: // do something // 将接收到的action.payload进行一系列操作，并拼接到state中 return state default: return state }} 最初的action由UI组件发起 12345678910111213141516171819202122import { connect } from 'react-redux'import { getMoreHomeList } from '../store/actionCreator'//省略JSX部分...// 以下使用react-redux映射（同步）state、dispatch，使结构更清晰，降低耦合度// 将redux的state映射到this.props中const mapState = state =&gt; ({ articleList: state.getIn(['home', 'articleList']), loading: state.getIn(['home', 'loading'])})// 将redux的store.dispatch映射到this.props中const mapDispatch = dipatch =&gt; ({ handleLoadMore(e) { e.preventDefault() // 通过dispatch发送action dipatch(getMoreHomeList()) }})export default connect(mapState, mapDispatch)(List); 通过上述章节，我们可以概括出redux-saga做为redux中间件的全部优点： 统一action的形式，在redux-saga中，从UI中dispatch的action为原始对象 集中处理异步等存在副作用的逻辑 通过转化effects函数，可以方便进行单元测试 完善和严谨的流程控制，可以较为清晰的控制复杂的逻辑。 参考:[https://www.jianshu.com/p/05b73d826425]","link":"/2020/09/15/%E4%BD%BF%E7%94%A8react-saga/"},{"title":"前端杂谈","text":"Recorder: Wee Chou z-index仅同级Element有效,父子关系只需修改子元素 npm init –yes 生成package.js 且全部选yes选项 **Element.closest()** 方法用来获取：匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。 很重要!!!!在事件委托上很常用 getBoundingClientRect() 获取坐标， 当元素没有left top值时，通过获取坐标来获取位置参数。 很重要！！！！ element.insertAdjacentHTML(position, text) 回流必将引起重绘, 而重绘不一定会引起回流(回流: 改变元素的布局或尺寸…;重绘: 仅改变元素的外观,不会影响布局) 基线总是与行内高度最高的元素一致的 边缘折叠,两个边距中较小的边距被较大的边距所取代 负页边距确实会对垂直格式产生影响，并影响页边距的折叠方式 vertical-align 改变基线的位置 display: grid; 网格布局 很好用 CSS中脱离文档流，bai也就是将元素从普通的布局排版中拿走，其他盒zhi子在定位的时候，会当做脱dao离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。 这个用于视口的meta标签，是网页与移动浏览器的接口。网页通过这个标签告诉移动浏览器，它希望浏览器如何渲染当前页面。 多列布局: column-width: 12em; column-width: 4(固定列数,宽度可变) 善于利用calc设定尺寸 -&gt; 例如 calc(50% - 10px) 不能从dispaly:none 开始过渡, 因为还没开始”绘制” 递归 {需要有个结尾} like return 0; 使用原型是为了共享属性和方法 所有引用类型都继承了Object","link":"/2022/08/06/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%B0%88/"},{"title":"初探Nuxtjs","text":"在我大致阅读完Vue的官方文档后，觉得不够过瘾，正好文档中有提到Nuxt，出于好奇，我打开了Nuxt的官方文档。 什么是NuxtJS简而言之，Nuxt是运行在node环境的SSR（服务端渲染）框架，且基于Vue。Vue负责开发多页应用，Nuxt在此之上再做拓展，可以直接用命令生成完整的html页面，在服务器端完成渲染。 什么是SSR在认识SSR之前，首先对CSR与SSR之间做个对比。 首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接HTML字符串（模板），通过一系列的数据处理之后，把整理好的HTML返回给客户端,浏览器相当于打开了一个页面。这种比如我们经常听说过的jsp,PHP,aspx也就是传统的MVC的开发。 SPA应用，到了Vue、React，单页面应用优秀的用户体验，逐渐成为了主流，页面整体式javaScript渲染出来的，称之为客户端渲染（CSR）。SPA渲染过程。由客户端访问URL发送请求到服务端，返回HTML结构（但是SPA的返回的HTML结构是非常的小的，只有一个基本的结构，如第一段代码所示）。客户端接收到返回结果之后，在客户端开始渲染HTML，渲染时执行对应javaScript，最后渲染template，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回json格式数据。客户端接收数据，然后完成最终渲染。 SPA虽然给服务器减轻了压力，但是也是有缺点的： 首屏渲染时间比较长：必须等待JavaScript加载完毕，并且执行完毕，才能渲染出首屏。SEO不友好：爬虫只能拿到一个div元素，认为页面是空的，不利于SEO。为了解决如上两个问题，出现了SSR解决方案，后端渲染出首屏的DOM结构返回，前端拿到内容带上首屏，后续的页面操作，再用单页面路由和渲染，称之为服务端渲染(SSR)。 SSR渲染流程是这样的，客户端发送URL请求到服务端，服务端读取对应的url的模板信息，在服务端做出html和数据的渲染，渲染完成之后返回html结构，客户端这时拿到的之后首屏页面的html结构。所以用户在浏览首屏的时候速度会很快，因为客户端不需要再次发送ajax请求。并不是做了SSR我们的页面就不属于SPA应用了，它仍然是一个独立的spa应用。 SSR是处于CSR与SPA应用之间的一个折中的方案，在渲染首屏的时候在服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在服务端接收到请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给客户端去渲染其他路由的页面。 via掘金:LuSir63227 Nuxt.js的特点（优点）： 基于Vue 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 EcmaScript6和EcmaScript7的语法支持 打包和压缩JavaScript和CSS HTML头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式预编译器SASS、LESS等等 支持HTTP/2推送 Nuxt环境搭建安装依赖开始之前需要先安装node，且版本大于8.9.0，下面是链接 https://nodejs.org/en/download/（建议安装LTS的最新版本） 从零构建创建项目文件夹，将工作目录切换到项目文件夹 12mkdir &lt;project-name&gt;cd &lt;project-name&gt; 然后创建依赖管理文件 1touch package.json 打开package.json，编辑基本信息 123456789{ \"name\": \"my-app\", \"scripts\": { \"dev\": \"nuxt\", \"build\": \"nuxt build\", \"generate\": \"nuxt generate\", \"start\": \"nuxt start\" }} 安装Nuxt一旦package.json被创建了，我们就可以通过包管理工具安装依赖，这里我们使用npm 1npm install nuxt 随后nuxt会被添加到package.json中，并自动生成node_modules文件夹 创建第一个页面在项目工作目录下： mkdir pagestouch pages/index.vue 该组件将作为默认页面的内容显示接下来为组件加入内容 123&lt;template&gt; &lt;h1&gt;Hello world!&lt;/h1&gt;&lt;template&gt; 启动服务在终端输入npm run dev命令，就会在本地http://localhost:3000 路由与单纯使用vue不同，nuxt对vue的路由进行了封装，依据pages的目录结构，nuxt会自动生成vue-router模块的路由配置 假设 pages的目录如下 └─pages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─index.vue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─index.vue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─one.vue 则Nuxt.js自动生成的路由配置如下： 12345678910111213141516171819router: { routes: [ { name: 'index', path: '/', component: 'pages/index.vue' }, { name: 'user', path: '/user', component: 'pages/user/index.vue' }, { name: 'user-one', path: '/user/one', component: 'pages/user/one.vue' } ]}","link":"/2020/08/27/%E5%88%9D%E6%8E%A2Nuxtjs/"},{"title":"防抖函数","text":"在使用React，实现通过onChange事件修改input.value与state.value值的过程中，发现每次修改值（每按下键盘一次），都会调用onChange对应的方法，而我们往往只需要拿到敲击完键盘最后得到的结果就行了，频繁且多余的请求会消耗不必要的性能。我们可以利用防抖函数解决这一问题。 123456789101112//防抖函数function debounce(fn, ms=500) { let timer = null return function(e) { // 想要访问异步事件属性 e.persist() if(timer!==null) clearTimeout(timer) timer = setTimeout(() =&gt; { fn.apply(this, arguments) }, ms); }} 这样一来，每次监听到事件，会先在全局创建一个定时器，并在事件结束的若干毫秒后，再执行对应方法。 注意事项 每次创建定时器之前，若已经存在timer，为了避免定时器叠加，要清除已存在的定时器 e.persist()的解释: If you want to access the event properties in an asynchronous way, you should call event.persist() on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.中文解释（并非翻译）：如果在react中想异步访问事件属性（如在setTimeout内），应该在是处理事件时调用event.persist()，这会从事件池中移除该合成函数并允许对该合成事件的引用被保留下来。 由于传入的fn会在外部调用，且需要外部的作用域，因此用到apply绑定this：fn.apply(this, arguments)","link":"/2020/09/03/React%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0/"},{"title":"原型模式","text":"什么是原型?我们创建的每个函数都有一个 prototype 属性，该属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。若按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的对象实例的原型对象。 原型是 Javascript 中的继承的基础，JavaScript 的继承就是基于原型的继承。 使用原型的好处？使用原型的好处是可以让所有对象实例共享属性和方法，而不用多次构建相同的属性或方法，占用多余的内存。 举一个最简单的例子： 123456789function Person() {}Person.prototype.name = \"wee\"; // 在Person原型中设定name属性var person1 = new Person();var person2 = new Person();console.log(person1.name);console.log(person2.name); // 两个同类但不同的实例都能从其原型中访问到name 创建实例对象最好的办法，是结合构造函数模式和原型模式。使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 1234567891011121314function SuperType(name) { this.name = name; this.colors = ['red','purple'];}SuperType.prototype.sayName = function() { console.log(this.name)}function SubType(name, age) { SuperType.call(this, name); // 继承属性,目的是为了让this指向SubType实例对象,使SuperType中的this this.age = age;}subType.prototype = new SuperType() // 继承方法var sub = new SubType('wee','')","link":"/2020/08/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"事件模型","text":"原始事件模型（DOM0级） 这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件： 在html代码中直接指定属性值： 1&lt;button id=\"demo\" type=\"button\" onclick=\"doSomeTing()\" /&gt; 在js代码中为: 1document.getElementsById(\"demo\").onclick = doSomeTing(); 优点：所有浏览器都兼容 缺点：1）逻辑与显示没有分离；2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。 因为这些缺点，虽然原始事件类型兼容所有浏览器，但仍不推荐使用。 DOM2事件模型 此模型是W3C制定的标准模型，现代浏览器（IE6~8除外）都已经遵循这个规范。W3C制定的事件模型中，一次事件的发生包含三个过程： 1.事件捕获阶段2.事件目标阶段3.事件冒泡阶段 如下图所示: &nbsp;IE 5.5: div -&gt; body -&gt; document &nbsp;IE 6.0: div -&gt; body -&gt; html -&gt; document &nbsp;Mozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window &nbsp;&nbsp;&nbsp;&nbsp;所有的事件类型都会经历事件捕获但是只有部分事件会经历事件冒泡阶段,例如submit事件就不会被冒泡。 事件的传播是可以阻止的： 在W3c中，使用stopPropagation（）方法 在IE下设置eve.cancelBubble = true；在捕获的过程中stopPropagation（）；后，后面的冒泡过程就不会发生了。 标准的事件监听器该如何绑定： &nbsp;&nbsp;&nbsp;&nbsp;addEventListener(“eventType”,”handler”,”true|false”);其中eventType指事件类型，注意不要加’on’前缀，与IE下不同。第二个参数是处理函数，第三个即用来指定是否在捕获阶段进行处理，一般设为false来与IE保持一致(默认设置)，除非你有特殊的逻辑需求。监听器的解除也类似：removeEventListner(“eventType”,”handler”,”true!false”); 事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。 摘自: [https://www.cnblogs.com/leftJS/p/10948138.html]","link":"/2020/08/11/%E4%BA%8B%E4%BB%B6/"},{"title":"基于Vue-cli2.x的项目构建流程","text":"记录使用vue-cli脚手架项目构建流程 &amp;&amp; Debug过程 Author: wee chou 环境参数nodejs &gt;=6.2.2npm &gt;= 3.9vue &gt;= 2.5.2IDE vscodeGitgithub平台账户 安装依赖 vscode 宇宙第一IDE 好用的（前端）插件： Chinese（友好的简体中文界面）ESLint（严格的代码审查）Live Server（在本地搭建临时的微服务器）Vetur（格式化代码） node.js 建议安装较为稳定的 LTS 版本 根据提示安装完成后,通过 node -v 命令校验是否安装成功 Vue CDN:https://cdn.jsdelivr.net/npm/vue/dist/vue.jshttps://unpkg.com/browse/vue@2.6.11/dist/vue.js 脚手架的依赖项包含了vue库，因此可以一步到位，不需要再次引用 Vue-cli 通过npm包管理工具全局安装vue-cli（npm是node的包管理工具，不用再次安装）npm install --global vue-cli 项目构建执行命令 vue init webpack Travel 经过一系列设置后，项目的整体架构就搭建好了 配置方法 别名alias 在使用vue-cli架构时，想要引入外部文件，可以使用语法糖‘@’简写路径，而‘@’代表src文件夹。想要添加自定义路径，可以在build/webpack.base.conf.js文件中进行设置 1234567resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), }}, 常见问题 less和less-loader版本号不一致 开发中想要用less添加样式，于是在终端安装依赖： &nbsp;&nbsp;npm install less less-loader --save 提示安装成功，在使用过程中却报了许多错误信息，通过查阅资料得知是因为less和less-loader版本号不一致。解决办法也很简单，卸载之前的less-loader，用添加版本号的方式重新安装： &nbsp;&nbsp;npm install less-loader@3 --save","link":"/2020/08/21/%E5%9F%BA%E4%BA%8EVue-cli2-x%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"title":"常见排序算法","text":"&nbsp;&nbsp;&nbsp;&nbsp;算法在平时的前端业务开发中其实不太能用得到，但了解其原理，可以提高我们的思维逻辑能力，也能够作为代码性能优化的知识储备。 排序冒泡排序 冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作会重复地进行，直到没有再需要交换的元素为止，此时排序完成。 以下是冒泡排序的基本实现步骤： 比较相邻的元素。如果第一个比第二个大，就交换它们的位置。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这样在最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上述步骤，直到没有任何一对数字需要比较为止。冒泡排序的时间复杂度为 O(n²)，其中 n 是要排序的元素个数。虽然冒泡排序是一个简单的算法，但它的效率较低，不适合处理大规模的数据。 用JS实现 1234567891011121314function bubbleSort(arr) { const len = arr.length; for (let i = 0; i &lt; len - 1; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr;}const arr = [5, 3, 8, 4, 2];console.log(bubbleSort(arr)); // 输出 [2, 3, 4, 5, 8] 快速排序 快速排序是一种高效的排序算法，它的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列。 以下是快速排序的基本实现步骤： 从数列中挑出一个基准值（通常选择第一个数）。 将所有比基准值小的元素移到基准值前面，将所有比基准值大的元素移到基准值后面（相同的数可以放到任一一边）。 递归地对小于基准值的子数列和大于基准值的子数列进行快速排序。 1234567891011121314151617181920function quickSort(arr) { if (arr.length &lt;= 1) { return arr; } const pivotIndex = Math.floor(arr.length / 2); // 选取基准值的下标 const pivot = arr.splice(pivotIndex, 1)[0]; // 选取基准值并从原数组中删除 const left = []; const right = []; for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return [...quickSort(left), pivot, ...quickSort(right)]; // 递归排序左右两个子数组并合并结果}const arr = [5, 3, 8, 4, 2];console.log(quickSort(arr)); // 输出 [2, 3, 4, 5, 8]","link":"/2020/12/29/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"理解虚拟DOM","text":"虚拟DOM并不是什么神奇的东西，它只是用来描述真实DOM的Javascript对象而已。 &nbsp;&nbsp;&nbsp;&nbsp;在传统的前端开发中，我们会大量使用DOM提供的API，直接对DOM进行增删改查一系列操作，然而每进行一次DOM操作，都会使页面重新渲染，相对来讲这是很消耗性能的。因此在前端优化中有一条原则：尽量减少DOM操作。 &nbsp;&nbsp;&nbsp;&nbsp;而虚拟DOM可以作为真实DOM的抽象，有其同等的作用，且更高效。它是一个独立的技术，只不过React使用了这项技术来提高自身性能。 &nbsp;&nbsp;&nbsp;&nbsp;在React的JSX中，每一个标签其实都可以用js来描述，例如以下DOM结构： 123&lt;div className='foo'&gt; &lt;h1&gt;Hello React&lt;/h1&gt;&lt;/div&gt; 可以用这样的javascript对象来描述： 123456789101112{ type: 'div', props: { className: 'foo', children: { type: 'h1', props: { children: 'Hello React' } } }} &nbsp;&nbsp;&nbsp;&nbsp;有了虚拟DOM这一层，当我们需要操作DOM时，就可以操作虚拟DOM，而不操作真实DOM，虚拟DOM是普通的JavaScript对象，访问JavaScript对象当然比访问真实DOM要快得多。到这里，大家可以发现，虚拟DOM并不是什么神奇的东西，它只是用来描述真实DOM的JavaScript对象而已。 \b 参考： 《React 进阶之路》","link":"/2022/10/27/%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM/"},{"title":"快速构建React单页应用","text":"习惯了Vue的开发模式，想尝试一下更加低粒度的React框架。 开发环境 node LTS latest VScode Create React App对于React初学者来说（比如此刻的我），快速构建应用无非省去了很多准备工作，从而提高开发效率。利用Create React App可以快速构建一个React单页应用，只需在终端执行下列命令。 &nbsp;&nbsp;npx create-react-app my-app &nbsp;&nbsp;cd my-app &nbsp;&nbsp;npm start 注意第一行的 npx 不是拼写错误 —— 它是 npm 5.2+ 附带的 package 运行工具。","link":"/2020/09/02/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"},{"title":"理解async&#x2F;await","text":"async/await是ES7中新增的语法糖，可以使JavaScript的异步操作（IO操作，对资源的操作，读文件，发送http请求，操作数据库）开发更加简洁 在理解asycn/await是什么之前，我们需要理解什么是Promise例如使用jquery中的Ajax，想要获取从服务端传来的返回值，我们往往会这么做 12345678910111213$.ajax({ url: 'json.php', type: 'get', // 设置的是请求参数 data: { id: 1, name: '张三' }, // 用于设置响应体的类型 注意 跟 data 参数没关系 dataType: 'json', success: function (res) { // 一旦设置的 dataType 选项，就不再关心 服务端 响应的 Content-Type 了 // 客户端会主观认为服务端返回的就是 JSON 格式的字符串 console.log(res) }}) 其中success对应的函数就是回调函数，我们可以用回调函数获取异步操作的结果 123456789101112var b = 0function foo(callback) { setTimeout(() =&gt; { b += 1 callback(b) }, 1000);}foo(res=&gt; { console.log(res)})// 1秒后打印 1 这么一看似乎用回调函数就能完美解决问题。但如果我们想要每秒给b加1，并持续3秒该怎么做呢？这时为了维持上下文，我们不得不嵌套回调函数 1234567891011121314151617var b = 0function foo(callback) { setTimeout(() =&gt; { b += 1 callback(b) }, 1000);}foo(() =&gt; { foo(() =&gt; { foo(res =&gt; { console.log(res) }) })})// 3秒后输出3 我们可以看到，照这个趋势下去，如果要获取10秒后的结果，代码会变得非常糟糕。 在ES6中，promise的出现拯救了这样的“回调地狱”。 promise提供了几个基本的api Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 如何使用把上面的例子改成promise 1234567891011121314151617function foo(b = 0) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { b += 1 resolve(b) }, 1000); })}foo().then(res=&gt;{ return foo(res)}).then(res=&gt;{ return foo(res)}).then(res=&gt; { console.log(res)})// 3秒后输出3 虽然代码量没有减少，但代码结构明显变得更加美观，逻辑也更加清晰，更重要的是promise非常灵活，只需要用promise包裹普通函数，若成功则用resolve接受结果，若失败则用reject接受失败信息，再创建promise实例对象，调用then方法使用resolve获取到的参数，调用catch方法使用reject获取到的参数。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 而async/await其实就是配合promise的语法糖12345678910111213141516async function foo() { const b = await after1s() // 相当于 const b = after1s().then(res=&gt;res) // 捕获异常 const b = after1s().catch(error=&gt;error) console.log(b)}function after1s() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(200) }, 1000); })}foo() // 1秒后输出200 用await修饰的对象，若是promise对象，则会默认接收resolve传递过来的resolve值，也就是默认执行了then方法。 （函数内部用了await，函数就必须用async修饰，不然会报错） 用async修饰的函数，其内部运行的任何函数都会被包装成promise对象。 await会阻塞线程（异步的调用变成同步的调用），以axios举例 12 参考：https://www.jianshu.com/p/063f7e490e9a","link":"/2020/09/17/%E7%90%86%E8%A7%A3async-await/"},{"title":"节流防抖","text":"前端开发中的防抖（Debouncing）和节流（Throttling）是优化 JavaScript 函数性能的两种常见方式。它们可以帮助控制函数被调用的频率，避免频繁触发一些高开销的操作，从而提高前端页面的性能和用户体验。 防抖防抖（Debouncing）的基本思想是，当事件被触发时，我们不立即执行该事件处理函数，而是等待一定时间后，再去执行该事件处理函数。如果在等待时间内再次触发了该事件，那么就重新计时。简单来说，防抖的作用是防止短时间内大量触发同一事件导致频繁更新DOM，而是将事件合并成一次处理。 具体实现 123456789101112131415// 防抖（立即执行版本）function debounce(fn, wait) { let timer = null return function () { let args = arguments let now = !timer timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; { timer = null }, wait) if (now) { fn.apply(this, args) } }} 节流节流（Throttling）的基本思想是，当事件被触发时，我们先判断当前是否有等待执行的延时函数。如果有，就不执行该事件处理函数，如果没有，就设置一个延时函数，在延时时间之后执行该事件处理函数。如果在等待时间内再次触发了该事件，那么就不做任何处理。简单来说，节流的作用是减少事件处理函数的触发次数，优化性能。 具体实现 1234567891011121314// 节流（定时器版本）function throttle(fn, wait) { let timer = null return function () { let context = this let args = arguments if (!timer) { timer = setTimeout(() =&gt; { timer = null fn.apply(context, args) }, wait) } }} 除了手动造轮子，实际开发中我们也可以使用 lodash 库提供的防抖和节流函数来实现。首先需要安装 lodash 库，然后在 Vue 组件中使用 import 引入该库，然后通过 Vue.mixin 方法来混入该库提供的防抖和节流函数，以便在组件中可以直接调用这些函数。 一些便于理解的比喻🍭 防抖就是公交车等人上车，有人上等5s，5s内又有人上再等5s / 节流就是公交车固定15分钟一班车 把防抖记成小哥送外卖，有新的单子来了先等五分钟，如果五分钟之内有新的单子，再等五分钟，直到五分钟之内没有单子，出门送外卖，也就是执行一次函数。希望对你理解有帮助 总结防抖和节流的区别在于它们控制函数执行的时机不同。防抖的基本思想是当事件被触发后，不立即执行事件处理函数，而是等待一段时间后再去执行。如果在等待时间内再次触发该事件，则重新计时。而节流的基本思想是当事件被触发后，先判断当前是否有等待执行的延时函数。如果有，就不执行事件处理函数；如果没有，就设置一个延时函数，在延时时间之后再去执行事件处理函数。","link":"/2022/07/15/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"title":"解读关键字&quot;new&quot;","text":"Author: Wee Chou 在new的过程中到底发生了什么？请先看下面的例子： 1234function Person(){}var person0 = Person() // undefinedvar person1 = new Person() // {} 在平日的开发中，我们对函数的调用无非有两种方法： 直接调用 使用new初始化函数 在上述例子中，我们可以很快理解直接调用返回undefined的原因，因为Person函数没有返回值。但为什么new Person()会返回一个空对象？这就涉及到构造函数的知识了。 那么什么是构造函数？ 我们知道Javascript和其他基于类的语言不同，他是基于对象的，在该语言中没有类的概念（ES6中的“类”也只是语法糖）。那么在Javascript中，我们如何创建对象呢。这就用到了构造函数。 123456function Person(name) { this.name = name;}var person = new Person('wee');console.log(person.name); // wee 这就是一个最简单的构造函数。 现在我们又会疑惑，里面的this是什么？ 我们创建对象，就需要结合this和new。 123function A() { //return this;} 其实，当我们使用new初始化一个函数时，函数内部会隐式返回一个this，如果我们把他想象成一个空对象，就很好解释了。 123456function A() { var obj = new Object(); // 在内存中创建一个空对象 return obj;}var a = new A(); // a指向obj 而赋予this属性和方法，其实等同于赋予这个空对象属性和方法。 12345678function A(name) { var obj = new Object(); obj.name = name; return obj;}var a = new A('wee');console.log(a.name); // wee 而这，就是传统的利用工厂模式创建对象。而利用this，就是构造函数模式创建对象。 那么言归正传，new的过程中到底发生了什么? 12345678910111213141516171819202122232425function A(){}function B(){ this.name = 'wee'; return this; // 显式返回}function _new(func){ var obj = new Object(); var result = func.call(obj); // 将this指向obj // 判断此时func的返回值，若为对象，则返回result，否则返回obj var _result = function() { if (typeof result == 'object') { return result; }else { return obj; } } return _result();}// var a = new A();// 等同于console.log(_new(A)); // {}// var b = new B();// 等同于console.log(_new(B)); // {name:'wee'} 我们可以看到，A中没有返回任何对象，通过_new(A)返回了一个空对象；B中返回了一个对象，则最后的返回结果就为该对象。","link":"/2020/08/07/%E8%A7%A3%E8%AF%BB%E5%85%B3%E9%94%AE%E5%AD%97-new/"},{"title":"解构赋值","text":"什么是解构赋值? 解构（destructuring）是ES6中新增的概念，这是将一个数据结构分解为更小的部分的过程。 某些应用场景中，当我们想要往函数中传入多个参数时，通常会这样做： 123456function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender;}var p1 = new Person('wee', 18, 1); 如果我们只需要一个实例，那并不能看到什么问题。但如果我们想要创建多个实例，而且包含相同的参数，这样无疑增加了代码冗余。 接下来我们尝试一下用对象控制传参数： 12345678910111213var person = { name: 'wee', age: 18, gender: 1}function Person(obj) { this.name = obj.name; this.age = obj.age; this.gender = obj.age;}var p1 = new Person(person);person.name = 'boy';var p2 = new Person(person); 此时，虽然我们可以使用一个对象控制传参了，但构造函数内部的代码量变多了，而且看上去着实不太美观。 那么有没有什么办法可以改善这种情况呢？我们可以使用解构赋值： 12345678910111213var person = { name: 'wee', age: 18, gender: 1}function Person({name, age, gender}) { this.name = name; this.age = age; this.gender = gender;}var p1 = new Person(person);person.name = 'boy';var p2 = new Person(person); 可以看到，我们使用解构，在构造函数内部使用参数之前，针对性地将传入对象“分解”，而不用再在内部逻辑中从对象取值。","link":"/2020/08/18/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"闭包","text":"Author: Wee chou 什么是闭包?许多开发者会因为“闭包”中的“包”想当然地以为只有被包裹才算闭包，比如函数内部“包”个函数，再在内部函数返回外部函数的局部变量。其实形成闭包的条件很简单。 1234var local = 0;function foo() { local++;} 是的，这就形成了一个闭包。形成闭包的条件： 内部函数访问外部函数参数 下面举一个经典的例子: 1234567891011121314function foo() { var local = 0; // 对于foo来说是局部变量 function bar() { local++; // 对于bar来说是外部变量, 此时访问了外部变量local console.log(local); } return bar; // 返回闭包到全局}var func = foo(); // 全局变量在执行过程中不会被回收(?)func(); // 1func(); // 2func(); // 3 就像这个例子里写的，我认为运用闭包最多的场景，就是隐藏变量，即无法在外部直接修改local。 &nbsp;&nbsp;&nbsp;&nbsp;例子中，唯一可以直接访问到local变量的，只有内部函数bar，当bar执行完毕后，会销毁自身，而bar中的局部作用域会释放到foo中，由于我们在全局引用了foo函数，使foo在执行完毕后并没有被立即销毁，又因为在foo中返回了内部函数bar，使得我们可以在全局持续访问并执行bar的内部操作，并保留foo的局部作用域，直到func不再被访问后被回收。 所以闭包只是一个定义，并不是设计者特意由设计出来的","link":"/2020/08/10/%E9%97%AD%E5%8C%85/"},{"title":"解决React组件样式污染","text":"在我用React写社区项目，利用浏览器开发工具进行调试时，偶然想到了样式污染的问题。在Vue中，我们可以给style标签添加scoped属性，解决样式污染的问题： 每个组件都会被赋予一个唯一的[data-*]属性，CSS也会随之添加对应选择器： 那么在React中，该如何解决类似的问题？网上有许多方法，在此我尝试了其中两种较主流的方法。 1.styled-components 首先我们需要安装它 yarn add styled-components or npm install --save styled-components 举一个简单但能体现特性的例子 123456789101112131415161718192021222324252627import React, { Component, Fragment } from 'react';//引入styled-componentsimport styled from 'styled-components'//修改了div的样式const myTitle = styled.div` font-size: ; color:red;`// 修改了button的样式const Button = styled.button` border:none; background-color:blue;`class App extends Component { render() { return ( // 使用Fragment标签可以仅包裹但不添加额外节点 &lt;Fragment&gt; &lt;Title&gt;标题&lt;/Title&gt; &lt;Button&gt;按钮&lt;/Button&gt; &lt;/Fragment&gt; ) }}export default App; 然后我们就能看到意料之中的结果 同时我们可以看到，styled-components给元素设置了某种规范的并且是随机的className，从而避免了样式污染。 但经过初步使用后，我并不喜欢这种解决方式（大概是因为在js里写css没有代码提示…），于是我开始尝试另一种方法。也是我最后选择的方法，CSS modules。 2.CSS modules使用方法：[https://www.w3cplus.com/react/css-modules-in-react.html] 我按照上述网站的方法进行了一系列配置，最终也得到了正确的结果，但似乎哪里有些差强人意。。。 CSS modules自动生成的className太长了。。。虽然对使用者来说不会有任影响，但对于常用开发者工具的开发者来说，至少对我来说，这实在是太糟糕了。我希望他能只留下最后的hash。然后我翻遍了google/baidu/CSDN/Stack Overflow/React官网/github issues等网站🐵查阅了许多资料，重启了n次服务器，最终还是没能解决问题。在网上看到最多的就是对css-loader中localIdentName属性的设置，但我尝试在各种位置设置，都没有用，于是我逆向查找到了引用这个属性的方法。。。 可以看到，localIdentName是灰色的，这代表在后面的函数体中并没有使用到这个属性，只使用到了localName 接下来就简单了，重新拼接出自己想要的字符串就行了，但这里最好的办法还是先判断是否传入localIdentName，将localName作为默认值，根据if返回结果，我想这也是作者的初衷。 好在最终得到了想要的结果(￣▽￣)~*","link":"/2020/09/09/%E8%A7%A3%E5%86%B3React%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81/"},{"title":"用hooks实现Redux","text":"什么是Hook以下是官方解释： Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 在传统的React开发中，我们可以使用Redux提供的组件去监听全局状态，通常需要四个步骤： 用redux中的createStore方法创建store实例，并传入reducer函数（传入state、action，导出state） 由组件调用store.dispatch(action = {type:xxx,value:xxx}) 在reducer中接收action，并根据action.type执行相应操作，最终返回state store更新state后，需要组件在合适位置（通常在constructor中）发布订阅，更新视图:12345678910class A extends Component { constructor() { super() ... store.subscribe(this.updateView) } updateView() { this.setState(store.getState()) }} 那么如何用hooks实现Redux的功能呢 用hooks实现的过程中，也可以看到很多Redux的影子。我将用一个简单的例子展示如何运用hooks实现Redux，该demo划分为四部分： DemoProvider（关键，提供全局服务） Demo（父组件） DemoButton（子组件1） DemoContent（子组件2） DemoProvider.js 1234567891011121314151617181920212223242526272829import React, { createContext, useReducer } from 'react';// React.createContext 提供全局上下文export const ColorContext = createContext({})// 创建动态变量用于设置action.typeexport const UPDATA_COLOR = 'UPDATE_COLOR'// 和Rudex中一样，作为一个独立的模块处理state// 根据dispatch传来的action，执行相应的操作，返回stateconst reducer = (state, action) =&gt; { switch(action.type){ case UPDATA_COLOR: return action.color default: return state }}export const Color = props =&gt; { const [color, dispatch] = useReducer(reducer, 'blue') return ( // Provider组件，用于数据共享 &lt;ColorContext.Provider value={{color, dispatch}}&gt; {/* 表示被包裹的子组件 */} {props.children} &lt;/ColorContext.Provider&gt; )} DemoButton.js 12345678910111213141516import React, { useContext } from 'react';import { ColorContext, UPDATA_COLOR } from './DemoProvider'function Button() { // 从全局上下文中获取dispatch方法 const {dispatch} = useContext(ColorContext) return ( &lt;div&gt; {/* 和Redux中一样，触发dispatch */} &lt;button onClick={()=&gt; {dispatch({type: UPDATA_COLOR, color: 'blue'})}}&gt;be blue&lt;/button&gt; &lt;button onClick={()=&gt; {dispatch({type: UPDATA_COLOR, color: 'red'})}}&gt;be red&lt;/button&gt; &lt;/div&gt; )}export default Button DemoContent.js 1234567891011121314import React, {useContext} from 'react';import {ColorContext} from './DemoProvider'function Content() { // 监听全局上下文的变化（reducer根据action改变state，在此做出响应） let {color} = useContext(ColorContext) return ( &lt;div&gt; &lt;h1 style={{color: color}}&gt;content&lt;/h1&gt; &lt;/div&gt; )}export default Content Demo.js 123456789101112131415161718192021import React from 'react'import Button from './DemoButton'import Content from './DemoContent'// 导入Providerimport {Color} from './DemoProvider'function Demo() { return ( &lt;div&gt; &lt;h1&gt;DEMO&lt;/h1&gt; &lt;hr /&gt; {/* 使用组件 */} &lt;Color&gt; &lt;Content /&gt; &lt;Button /&gt; &lt;/Color&gt; &lt;/div&gt; )}export default Demo 可以看到，无论用hooks还是Redux，目的都是为了创建一个全局状态管理容器，它们的数据流也是一样的：","link":"/2020/09/07/%E7%94%A8hooks%E5%AE%9E%E7%8E%B0react-redux/"}],"tags":[{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"redux-saga","slug":"redux-saga","link":"/tags/redux-saga/"},{"name":"issues","slug":"issues","link":"/tags/issues/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"debounce","slug":"debounce","link":"/tags/debounce/"},{"name":"Vue-cli2.x","slug":"Vue-cli2-x","link":"/tags/Vue-cli2-x/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"vdom","slug":"vdom","link":"/tags/vdom/"},{"name":"Diff","slug":"Diff","link":"/tags/Diff/"},{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","link":"/tags/ECMAScript-6/"},{"name":"CSS module","slug":"CSS-module","link":"/tags/CSS-module/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"less-loader","slug":"less-loader","link":"/tags/less-loader/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Flask","slug":"Flask","link":"/categories/Flask/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"日记","slug":"前端/日记","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%97%A5%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Mac OS","slug":"Mac-OS","link":"/categories/Mac-OS/"},{"name":"models","slug":"Flask/models","link":"/categories/Flask/models/"},{"name":"redux-saga","slug":"React/redux-saga","link":"/categories/React/redux-saga/"},{"name":"ToDoList","slug":"React/ToDoList","link":"/categories/React/ToDoList/"},{"name":"front end issues","slug":"front-end-issues","link":"/categories/front-end-issues/"},{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"虚拟dom","slug":"React/虚拟dom","link":"/categories/React/%E8%99%9A%E6%8B%9Fdom/"},{"name":"Create React App","slug":"React/Create-React-App","link":"/categories/React/Create-React-App/"},{"name":"应用推荐","slug":"Mac-OS/应用推荐","link":"/categories/Mac-OS/%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90/"},{"name":"async","slug":"Javascript/async","link":"/categories/Javascript/async/"},{"name":"性能优化","slug":"性能优化","link":"/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"new关键字","slug":"Javascript/new关键字","link":"/categories/Javascript/new%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"ES6","slug":"Javascript/ES6","link":"/categories/Javascript/ES6/"},{"name":"作用域","slug":"Javascript/作用域","link":"/categories/Javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"Javascript/闭包","link":"/categories/Javascript/%E9%97%AD%E5%8C%85/"},{"name":"解决样式污染","slug":"React/解决样式污染","link":"/categories/React/%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E6%B1%A1%E6%9F%93/"},{"name":"Hook","slug":"React/Hook","link":"/categories/React/Hook/"},{"name":"start","slug":"Nuxt/start","link":"/categories/Nuxt/start/"},{"name":"节流防抖","slug":"Javascript/节流防抖","link":"/categories/Javascript/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"name":"原型","slug":"Javascript/原型","link":"/categories/Javascript/%E5%8E%9F%E5%9E%8B/"},{"name":"event","slug":"Javascript/event","link":"/categories/Javascript/event/"},{"name":"Vue-cli2.x","slug":"Vue/Vue-cli2-x","link":"/categories/Vue/Vue-cli2-x/"}]}